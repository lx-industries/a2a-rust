//! Type conversions between WIT types and a2a-types.

// Allow unused functions - these are utility functions that may be used by
// future server implementation or other components.
#![allow(dead_code)]

// WIT types are generated by wit_bindgen and available through different module paths:
// - `crate::a2a::protocol::types` - for type definitions (Role, TaskState, Part, etc.)
// - `crate::exports::a2a::protocol::client` - for client exports (MessageSendParams, SendResponse, Task, Error)
// Both paths expose the same types, but we use the types module for foundational types.

use crate::a2a::protocol::types::{
    Artifact, Message, MessageSendConfig, Part, Role, TaskState, TaskStatus, TextPart,
};
use crate::exports::a2a::protocol::client::{Error, MessageSendParams, SendResponse, Task};

// Re-export types used in tests
#[cfg(test)]
use crate::a2a::protocol::types::{DataPart, FileContent, FilePart};

/// Convert WIT Role to a2a-types Role (as i32 for prost enum).
pub fn role_to_a2a(role: Role) -> i32 {
    match role {
        Role::User => a2a_types::Role::User as i32,
        Role::Agent => a2a_types::Role::Agent as i32,
    }
}

/// Convert a2a-types Role (i32) to WIT Role.
pub fn role_from_a2a(role: i32) -> Role {
    match a2a_types::Role::try_from(role) {
        Ok(a2a_types::Role::User) => Role::User,
        Ok(a2a_types::Role::Agent) => Role::Agent,
        _ => Role::User, // Default to User for unknown/unspecified
    }
}

/// Convert WIT TaskState to a2a-types TaskState (as i32 for prost enum).
pub fn task_state_to_a2a(state: TaskState) -> i32 {
    match state {
        TaskState::Submitted => a2a_types::TaskState::Submitted as i32,
        TaskState::Working => a2a_types::TaskState::Working as i32,
        TaskState::InputRequired => a2a_types::TaskState::InputRequired as i32,
        TaskState::Completed => a2a_types::TaskState::Completed as i32,
        TaskState::Canceled => a2a_types::TaskState::Cancelled as i32,
        TaskState::Failed => a2a_types::TaskState::Failed as i32,
        TaskState::Rejected => a2a_types::TaskState::Rejected as i32,
        TaskState::AuthRequired => a2a_types::TaskState::AuthRequired as i32,
        TaskState::Unknown => a2a_types::TaskState::Unspecified as i32,
    }
}

/// Convert a2a-types TaskState (i32) to WIT TaskState.
pub fn task_state_from_a2a(state: i32) -> TaskState {
    match a2a_types::TaskState::try_from(state) {
        Ok(a2a_types::TaskState::Submitted) => TaskState::Submitted,
        Ok(a2a_types::TaskState::Working) => TaskState::Working,
        Ok(a2a_types::TaskState::InputRequired) => TaskState::InputRequired,
        Ok(a2a_types::TaskState::Completed) => TaskState::Completed,
        Ok(a2a_types::TaskState::Cancelled) => TaskState::Canceled,
        Ok(a2a_types::TaskState::Failed) => TaskState::Failed,
        Ok(a2a_types::TaskState::Rejected) => TaskState::Rejected,
        Ok(a2a_types::TaskState::AuthRequired) => TaskState::AuthRequired,
        _ => TaskState::Unknown, // Unspecified or unknown maps to Unknown
    }
}

/// Convert WIT Part to a2a-types Part.
///
/// Note: Only TextPart is fully implemented. FilePart and DataPart return errors.
pub fn part_to_a2a(part: Part) -> Result<a2a_types::Part, String> {
    match part {
        Part::Text(text_part) => Ok(a2a_types::Part {
            part: Some(a2a_types::part::Part::Text(text_part.text)),
            metadata: None,
        }),
        Part::File(_) => Err("FilePart not implemented".to_string()),
        Part::Data(_) => Err("DataPart not implemented".to_string()),
    }
}

/// Convert a2a-types Part to WIT Part.
///
/// Note: Only TextPart is fully implemented. FilePart and DataPart return errors.
pub fn part_from_a2a(part: &a2a_types::Part) -> Result<Part, String> {
    match &part.part {
        Some(a2a_types::part::Part::Text(text)) => Ok(Part::Text(TextPart { text: text.clone() })),
        Some(a2a_types::part::Part::File(_)) => Err("FilePart not implemented".to_string()),
        Some(a2a_types::part::Part::Data(_)) => Err("DataPart not implemented".to_string()),
        None => Err("Part has no content".to_string()),
    }
}

/// Convert WIT Message to a2a-types Message.
pub fn message_to_a2a(msg: Message) -> Result<a2a_types::Message, String> {
    let parts: Result<Vec<_>, _> = msg.parts.into_iter().map(part_to_a2a).collect();

    Ok(a2a_types::Message {
        role: role_to_a2a(msg.role),
        parts: parts?,
        // In prost-generated types, these are String not Option<String>
        message_id: msg.message_id.unwrap_or_default(),
        task_id: msg.task_id.unwrap_or_default(),
        context_id: msg.context_id.unwrap_or_default(),
        reference_task_ids: vec![],
        extensions: vec![],
        metadata: None,
    })
}

/// Convert a2a-types Message to WIT Message.
pub fn message_from_a2a(msg: &a2a_types::Message) -> Result<Message, String> {
    let parts: Result<Vec<_>, _> = msg.parts.iter().map(part_from_a2a).collect();

    Ok(Message {
        role: role_from_a2a(msg.role),
        parts: parts?,
        // Convert from String to Option<String> for WIT
        message_id: if msg.message_id.is_empty() {
            None
        } else {
            Some(msg.message_id.clone())
        },
        task_id: if msg.task_id.is_empty() {
            None
        } else {
            Some(msg.task_id.clone())
        },
        context_id: if msg.context_id.is_empty() {
            None
        } else {
            Some(msg.context_id.clone())
        },
    })
}

/// Convert a2a-types Artifact to WIT Artifact.
pub fn artifact_from_a2a(artifact: &a2a_types::Artifact) -> Result<Artifact, String> {
    let parts: Result<Vec<_>, _> = artifact.parts.iter().map(part_from_a2a).collect();

    Ok(Artifact {
        artifact_id: artifact.artifact_id.clone(),
        // In prost-generated types, name and description are String, convert to Option for WIT
        name: if artifact.name.is_empty() {
            None
        } else {
            Some(artifact.name.clone())
        },
        description: if artifact.description.is_empty() {
            None
        } else {
            Some(artifact.description.clone())
        },
        parts: parts?,
    })
}

/// Convert a2a-types TaskStatus to WIT TaskStatus.
pub fn task_status_from_a2a(status: &a2a_types::TaskStatus) -> Result<TaskStatus, String> {
    let message = match &status.message {
        Some(msg) => Some(message_from_a2a(msg)?),
        None => None,
    };

    Ok(TaskStatus {
        state: task_state_from_a2a(status.state),
        message,
        // Convert pbjson_types::Timestamp to RFC 3339 string
        timestamp: status.timestamp.as_ref().map(|ts| {
            // Convert to seconds and nanos to RFC3339
            let secs = ts.seconds;
            let nanos = ts.nanos as u32;
            if let Some(dt) = chrono::DateTime::from_timestamp(secs, nanos) {
                dt.to_rfc3339()
            } else {
                // Fallback for invalid timestamps
                String::new()
            }
        }),
    })
}

/// Convert a2a-types Task to WIT Task.
pub fn task_from_a2a(task: &a2a_types::Task) -> Result<Task, String> {
    // a2a-types Task has history and artifacts as Vec (not Option<Vec>)
    // WIT Task has them as Option<list<...>>
    let history = if task.history.is_empty() {
        None
    } else {
        let converted: Result<Vec<_>, _> = task.history.iter().map(message_from_a2a).collect();
        Some(converted?)
    };

    let artifacts = if task.artifacts.is_empty() {
        None
    } else {
        let converted: Result<Vec<_>, _> = task.artifacts.iter().map(artifact_from_a2a).collect();
        Some(converted?)
    };

    // In prost-generated types, status is Option<TaskStatus>
    let status = task
        .status
        .as_ref()
        .ok_or_else(|| "Task has no status".to_string())?;

    Ok(Task {
        id: task.id.clone(),
        context_id: task.context_id.clone(),
        status: task_status_from_a2a(status)?,
        history,
        artifacts,
    })
}

/// Convert WIT MessageSendConfig to a2a-types SendMessageConfiguration.
pub fn message_send_config_to_a2a(
    config: MessageSendConfig,
) -> a2a_types::SendMessageConfiguration {
    a2a_types::SendMessageConfiguration {
        accepted_output_modes: config.accepted_output_modes.unwrap_or_default(),
        history_length: config.history_length.map(|v| v as i32),
        // In prost-generated types, blocking is bool not Option<bool>
        blocking: config.blocking.unwrap_or(false),
        push_notification_config: None,
    }
}

/// Convert WIT MessageSendParams to a2a-types SendMessageRequest.
pub fn message_send_params_to_a2a(
    params: MessageSendParams,
) -> Result<a2a_types::SendMessageRequest, String> {
    let configuration = params.configuration.map(message_send_config_to_a2a);

    Ok(a2a_types::SendMessageRequest {
        tenant: String::new(),
        request: Some(message_to_a2a(params.message)?),
        configuration,
        metadata: None,
    })
}

/// Convert a2a-types SendMessageResponse to WIT SendResponse.
pub fn send_response_from_a2a(
    response: &a2a_types::SendMessageResponse,
) -> Result<SendResponse, String> {
    // In prost-generated types, SendMessageResponse has a payload oneof field
    match &response.payload {
        Some(a2a_types::send_message_response::Payload::Task(task)) => {
            Ok(SendResponse::Task(task_from_a2a(task)?))
        }
        Some(a2a_types::send_message_response::Payload::Msg(msg)) => {
            Ok(SendResponse::Message(message_from_a2a(msg)?))
        }
        None => Err("SendMessageResponse has no payload".to_string()),
    }
}

/// Convert a String error to WIT Error.
pub fn error_from_string(msg: String) -> Error {
    Error {
        code: -32603, // Internal error
        message: msg,
    }
}

// Note: JsonrpcError type no longer exists in prost-generated types.
// Error handling is now done directly in client.rs through a2a_client::Error.

// ============================================================================
// Server-side conversions (a2a-types -> WIT for params, WIT -> a2a-types for responses)
// ============================================================================

/// Convert a2a-types SendMessageRequest to WIT MessageSendParams.
///
/// Used by the server to convert incoming JSON-RPC params to WIT types
/// before calling the agent interface.
pub fn message_send_params_to_wit(
    params: &a2a_types::SendMessageRequest,
) -> Result<MessageSendParams, String> {
    let configuration = params
        .configuration
        .as_ref()
        .map(message_send_config_from_a2a);

    // In prost-generated types, request is Option<Message>
    let message = params
        .request
        .as_ref()
        .ok_or_else(|| "SendMessageRequest has no message".to_string())?;

    Ok(MessageSendParams {
        message: message_from_a2a(message)?,
        configuration,
    })
}

/// Convert a2a-types SendMessageConfiguration to WIT MessageSendConfig.
fn message_send_config_from_a2a(config: &a2a_types::SendMessageConfiguration) -> MessageSendConfig {
    MessageSendConfig {
        accepted_output_modes: if config.accepted_output_modes.is_empty() {
            None
        } else {
            Some(config.accepted_output_modes.clone())
        },
        history_length: config.history_length.map(|v| v as u32),
        // In prost-generated types, blocking is bool not Option<bool>
        blocking: Some(config.blocking),
    }
}

/// Convert WIT SendResponse to a2a-types SendMessageResponse.
///
/// Used by the server to convert agent interface responses back to
/// a2a-types for JSON serialization.
pub fn send_response_from_wit(response: &SendResponse) -> a2a_types::SendMessageResponse {
    // In prost-generated types, SendMessageResponse uses a payload oneof
    match response {
        SendResponse::Task(task) => a2a_types::SendMessageResponse {
            payload: Some(a2a_types::send_message_response::Payload::Task(
                task_from_wit(task),
            )),
        },
        SendResponse::Message(msg) => a2a_types::SendMessageResponse {
            payload: Some(a2a_types::send_message_response::Payload::Msg(
                message_to_a2a_clone(msg),
            )),
        },
    }
}

/// Convert WIT Task to a2a-types Task.
///
/// Used by the server to convert agent interface responses back to
/// a2a-types for JSON serialization.
pub fn task_from_wit(task: &Task) -> a2a_types::Task {
    let history = task
        .history
        .as_ref()
        .map(|h| h.iter().map(message_to_a2a_clone).collect())
        .unwrap_or_default();

    let artifacts = task
        .artifacts
        .as_ref()
        .map(|a| a.iter().map(artifact_to_a2a).collect())
        .unwrap_or_default();

    a2a_types::Task {
        id: task.id.clone(),
        context_id: task.context_id.clone(),
        // In prost-generated types, status is Option<TaskStatus>
        status: Some(task_status_to_a2a_struct(&task.status)),
        history,
        artifacts,
        metadata: None,
    }
}

/// Convert WIT TaskStatus to a2a-types TaskStatus struct.
fn task_status_to_a2a_struct(status: &TaskStatus) -> a2a_types::TaskStatus {
    let message = status.message.as_ref().map(message_to_a2a_clone);
    // Parse RFC 3339 timestamp string to pbjson_types::Timestamp
    let timestamp = status.timestamp.as_ref().and_then(|ts| {
        chrono::DateTime::parse_from_rfc3339(ts).ok().map(|dt| {
            let dt_utc = dt.with_timezone(&chrono::Utc);
            pbjson_types::Timestamp {
                seconds: dt_utc.timestamp(),
                nanos: dt_utc.timestamp_subsec_nanos() as i32,
            }
        })
    });

    a2a_types::TaskStatus {
        state: task_state_to_a2a(status.state),
        message,
        timestamp,
    }
}

/// Convert WIT Message to a2a-types Message (clone-based, for response conversion).
fn message_to_a2a_clone(msg: &Message) -> a2a_types::Message {
    let parts: Vec<_> = msg
        .parts
        .iter()
        .filter_map(|p| part_to_a2a_clone(p).ok())
        .collect();

    a2a_types::Message {
        role: role_to_a2a(msg.role),
        parts,
        // In prost-generated types, these are String not Option<String>
        message_id: msg.message_id.clone().unwrap_or_default(),
        task_id: msg.task_id.clone().unwrap_or_default(),
        context_id: msg.context_id.clone().unwrap_or_default(),
        reference_task_ids: vec![],
        extensions: vec![],
        metadata: None,
    }
}

/// Convert WIT Part to a2a-types Part (clone-based).
fn part_to_a2a_clone(part: &Part) -> Result<a2a_types::Part, String> {
    match part {
        Part::Text(text_part) => Ok(a2a_types::Part {
            part: Some(a2a_types::part::Part::Text(text_part.text.clone())),
            metadata: None,
        }),
        Part::File(_) => Err("FilePart not implemented".to_string()),
        Part::Data(_) => Err("DataPart not implemented".to_string()),
    }
}

/// Convert WIT Artifact to a2a-types Artifact.
fn artifact_to_a2a(artifact: &Artifact) -> a2a_types::Artifact {
    let parts: Vec<_> = artifact
        .parts
        .iter()
        .filter_map(|p| part_to_a2a_clone(p).ok())
        .collect();

    a2a_types::Artifact {
        artifact_id: artifact.artifact_id.clone(),
        // In prost-generated types, name and description are String not Option<String>
        name: artifact.name.clone().unwrap_or_default(),
        description: artifact.description.clone().unwrap_or_default(),
        parts,
        extensions: vec![],
        metadata: None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_role_conversion() {
        // role_to_a2a now returns i32
        assert_eq!(role_to_a2a(Role::User), a2a_types::Role::User as i32);
        assert_eq!(role_to_a2a(Role::Agent), a2a_types::Role::Agent as i32);
        // role_from_a2a now takes i32
        assert!(matches!(
            role_from_a2a(a2a_types::Role::User as i32),
            Role::User
        ));
        assert!(matches!(
            role_from_a2a(a2a_types::Role::Agent as i32),
            Role::Agent
        ));
    }

    #[test]
    fn test_task_state_conversion() {
        // task_state_to_a2a now returns i32
        assert_eq!(
            task_state_to_a2a(TaskState::Submitted),
            a2a_types::TaskState::Submitted as i32
        );
        assert_eq!(
            task_state_to_a2a(TaskState::Working),
            a2a_types::TaskState::Working as i32
        );
        assert_eq!(
            task_state_to_a2a(TaskState::InputRequired),
            a2a_types::TaskState::InputRequired as i32
        );
        assert_eq!(
            task_state_to_a2a(TaskState::Completed),
            a2a_types::TaskState::Completed as i32
        );
        assert_eq!(
            task_state_to_a2a(TaskState::Canceled),
            a2a_types::TaskState::Cancelled as i32
        );
        assert_eq!(
            task_state_to_a2a(TaskState::Failed),
            a2a_types::TaskState::Failed as i32
        );
        assert_eq!(
            task_state_to_a2a(TaskState::Rejected),
            a2a_types::TaskState::Rejected as i32
        );
        assert_eq!(
            task_state_to_a2a(TaskState::AuthRequired),
            a2a_types::TaskState::AuthRequired as i32
        );
        assert_eq!(
            task_state_to_a2a(TaskState::Unknown),
            a2a_types::TaskState::Unspecified as i32
        );
    }

    #[test]
    fn test_text_part_conversion() {
        let wit_part = Part::Text(TextPart {
            text: "hello".to_string(),
        });
        let a2a_part = part_to_a2a(wit_part).unwrap();
        // Part is now a struct with a part field (oneof)
        assert!(matches!(
            a2a_part.part,
            Some(a2a_types::part::Part::Text(_))
        ));

        if let Some(a2a_types::part::Part::Text(text)) = a2a_part.part {
            assert_eq!(text, "hello");
        }
    }

    #[test]
    fn test_file_part_not_implemented() {
        let wit_part = Part::File(FilePart {
            file: FileContent {
                name: None,
                mime_type: None,
                uri: None,
                bytes: None,
            },
        });
        assert!(part_to_a2a(wit_part).is_err());
    }

    #[test]
    fn test_data_part_not_implemented() {
        let wit_part = Part::Data(DataPart {
            data: "{}".to_string(),
            mime_type: None,
        });
        assert!(part_to_a2a(wit_part).is_err());
    }

    #[test]
    fn test_message_send_params_to_a2a() {
        // Create a WIT MessageSendParams with message and configuration
        let wit_params = MessageSendParams {
            message: Message {
                role: Role::User,
                parts: vec![Part::Text(TextPart {
                    text: "Hello, agent!".to_string(),
                })],
                message_id: Some("msg-123".to_string()),
                task_id: Some("task-456".to_string()),
                context_id: Some("ctx-789".to_string()),
            },
            configuration: Some(MessageSendConfig {
                accepted_output_modes: Some(vec!["text".to_string(), "json".to_string()]),
                history_length: Some(10),
                blocking: Some(true),
            }),
        };

        // Convert to a2a-types (now returns SendMessageRequest)
        let a2a_params = message_send_params_to_a2a(wit_params).unwrap();

        // Verify message fields - request is now Option<Message>
        let message = a2a_params.request.unwrap();
        assert_eq!(message.role, a2a_types::Role::User as i32);
        assert_eq!(message.parts.len(), 1);
        if let Some(a2a_types::part::Part::Text(text)) = &message.parts[0].part {
            assert_eq!(text, "Hello, agent!");
        } else {
            panic!("Expected Text part");
        }
        // In prost-generated types, these are String not Option<String>
        assert_eq!(message.message_id, "msg-123");
        assert_eq!(message.task_id, "task-456");
        assert_eq!(message.context_id, "ctx-789");

        // Verify configuration fields
        let config = a2a_params.configuration.unwrap();
        assert_eq!(
            config.accepted_output_modes,
            vec!["text".to_string(), "json".to_string()]
        );
        assert_eq!(config.history_length, Some(10));
        // In prost-generated types, blocking is bool not Option<bool>
        assert!(config.blocking);
    }

    #[test]
    fn test_task_from_a2a_with_history() {
        // Create an a2a-types Task with non-empty history
        // In prost-generated types, status is Option<TaskStatus>, role is i32,
        // message fields are String not Option<String>, and Part uses oneof
        let a2a_task = a2a_types::Task {
            id: "task-001".to_string(),
            context_id: "ctx-001".to_string(),
            status: Some(a2a_types::TaskStatus {
                state: a2a_types::TaskState::Working as i32,
                message: None,
                timestamp: None,
            }),
            history: vec![
                a2a_types::Message {
                    role: a2a_types::Role::User as i32,
                    parts: vec![a2a_types::Part {
                        part: Some(a2a_types::part::Part::Text("First message".to_string())),
                        metadata: None,
                    }],
                    message_id: "msg-1".to_string(),
                    task_id: "task-001".to_string(),
                    context_id: "ctx-001".to_string(),
                    reference_task_ids: vec![],
                    extensions: vec![],
                    metadata: None,
                },
                a2a_types::Message {
                    role: a2a_types::Role::Agent as i32,
                    parts: vec![a2a_types::Part {
                        part: Some(a2a_types::part::Part::Text("Second message".to_string())),
                        metadata: None,
                    }],
                    message_id: "msg-2".to_string(),
                    task_id: "task-001".to_string(),
                    context_id: "ctx-001".to_string(),
                    reference_task_ids: vec![],
                    extensions: vec![],
                    metadata: None,
                },
            ],
            artifacts: vec![],
            metadata: None,
        };

        // Convert to WIT Task
        let wit_task = task_from_a2a(&a2a_task).unwrap();

        // Verify task fields
        assert_eq!(wit_task.id, "task-001");
        assert_eq!(wit_task.context_id, "ctx-001");
        assert!(matches!(wit_task.status.state, TaskState::Working));

        // Verify history is correctly converted
        let history = wit_task.history.expect("Expected history to be Some");
        assert_eq!(history.len(), 2);

        // Check first message
        assert!(matches!(history[0].role, Role::User));
        assert_eq!(history[0].parts.len(), 1);
        if let Part::Text(tp) = &history[0].parts[0] {
            assert_eq!(tp.text, "First message");
        } else {
            panic!("Expected TextPart");
        }

        // Check second message
        assert!(matches!(history[1].role, Role::Agent));
        if let Part::Text(tp) = &history[1].parts[0] {
            assert_eq!(tp.text, "Second message");
        } else {
            panic!("Expected TextPart");
        }
    }

    // Note: test_error_from_jsonrpc_preserves_code was removed because
    // JsonrpcError type no longer exists in prost-generated types.

    #[test]
    fn test_error_from_transport_uses_32603() {
        // Test that error_from_string uses code -32603 (internal error)
        let error_message = "Transport layer failure: connection reset".to_string();
        let wit_err = error_from_string(error_message.clone());

        assert_eq!(
            wit_err.code, -32603,
            "Transport errors should use -32603 (internal error)"
        );
        assert_eq!(wit_err.message, error_message);

        // Test with another message to ensure consistency
        let another_error = "Network timeout".to_string();
        let wit_err2 = error_from_string(another_error.clone());

        assert_eq!(wit_err2.code, -32603);
        assert_eq!(wit_err2.message, another_error);
    }
}
