//! Type conversions between WIT types and a2a-types.

// Allow unused functions - these are utility functions that may be used by
// future server implementation or other components.
#![allow(dead_code)]

// WIT types are generated by wit_bindgen and available through different module paths:
// - `crate::a2a::protocol::types` - for type definitions (Role, TaskState, Part, etc.)
// - `crate::exports::a2a::protocol::client` - for client exports (MessageSendParams, SendResponse, Task, Error)
// Both paths expose the same types, but we use the types module for foundational types.

use crate::a2a::protocol::types::{
    Artifact, Message, MessageSendConfig, Part, Role, TaskState, TaskStatus, TextPart,
};
use crate::exports::a2a::protocol::client::{Error, MessageSendParams, SendResponse, Task};

// Re-export types used in tests
#[cfg(test)]
use crate::a2a::protocol::types::{DataPart, FileContent, FilePart};

/// Convert WIT Role to a2a-types Role.
pub fn role_to_a2a(role: Role) -> a2a_types::Role {
    match role {
        Role::User => a2a_types::Role::User,
        Role::Agent => a2a_types::Role::Agent,
    }
}

/// Convert a2a-types Role to WIT Role.
pub fn role_from_a2a(role: &a2a_types::Role) -> Role {
    match role {
        a2a_types::Role::User => Role::User,
        a2a_types::Role::Agent => Role::Agent,
    }
}

/// Convert WIT TaskState to a2a-types TaskState.
pub fn task_state_to_a2a(state: TaskState) -> a2a_types::TaskState {
    match state {
        TaskState::Submitted => a2a_types::TaskState::Submitted,
        TaskState::Working => a2a_types::TaskState::Working,
        TaskState::InputRequired => a2a_types::TaskState::InputRequired,
        TaskState::Completed => a2a_types::TaskState::Completed,
        TaskState::Canceled => a2a_types::TaskState::Canceled,
        TaskState::Failed => a2a_types::TaskState::Failed,
        TaskState::Rejected => a2a_types::TaskState::Rejected,
        TaskState::AuthRequired => a2a_types::TaskState::AuthRequired,
        TaskState::Unknown => a2a_types::TaskState::Unknown,
    }
}

/// Convert a2a-types TaskState to WIT TaskState.
pub fn task_state_from_a2a(state: &a2a_types::TaskState) -> TaskState {
    match state {
        a2a_types::TaskState::Submitted => TaskState::Submitted,
        a2a_types::TaskState::Working => TaskState::Working,
        a2a_types::TaskState::InputRequired => TaskState::InputRequired,
        a2a_types::TaskState::Completed => TaskState::Completed,
        a2a_types::TaskState::Canceled => TaskState::Canceled,
        a2a_types::TaskState::Failed => TaskState::Failed,
        a2a_types::TaskState::Rejected => TaskState::Rejected,
        a2a_types::TaskState::AuthRequired => TaskState::AuthRequired,
        a2a_types::TaskState::Unknown => TaskState::Unknown,
    }
}

/// Convert WIT Part to a2a-types Part.
///
/// Note: Only TextPart is fully implemented. FilePart and DataPart return errors.
pub fn part_to_a2a(part: Part) -> Result<a2a_types::Part, String> {
    match part {
        Part::Text(text_part) => Ok(a2a_types::Part::TextPart(a2a_types::TextPart {
            kind: "text".to_string(),
            text: text_part.text,
            metadata: Default::default(),
        })),
        Part::File(_) => Err("FilePart not implemented".to_string()),
        Part::Data(_) => Err("DataPart not implemented".to_string()),
    }
}

/// Convert a2a-types Part to WIT Part.
///
/// Note: Only TextPart is fully implemented. FilePart and DataPart return errors.
pub fn part_from_a2a(part: &a2a_types::Part) -> Result<Part, String> {
    match part {
        a2a_types::Part::TextPart(text_part) => Ok(Part::Text(TextPart {
            text: text_part.text.clone(),
        })),
        a2a_types::Part::FilePart(_) => Err("FilePart not implemented".to_string()),
        a2a_types::Part::DataPart(_) => Err("DataPart not implemented".to_string()),
    }
}

/// Convert WIT Message to a2a-types Message.
pub fn message_to_a2a(msg: Message) -> Result<a2a_types::Message, String> {
    let parts: Result<Vec<_>, _> = msg.parts.into_iter().map(part_to_a2a).collect();

    Ok(a2a_types::Message {
        role: role_to_a2a(msg.role),
        parts: parts?,
        message_id: msg.message_id,
        task_id: msg.task_id,
        context_id: msg.context_id,
        kind: None,
        reference_task_ids: vec![],
        extensions: vec![],
        metadata: Default::default(),
    })
}

/// Convert a2a-types Message to WIT Message.
pub fn message_from_a2a(msg: &a2a_types::Message) -> Result<Message, String> {
    let parts: Result<Vec<_>, _> = msg.parts.iter().map(part_from_a2a).collect();

    Ok(Message {
        role: role_from_a2a(&msg.role),
        parts: parts?,
        message_id: msg.message_id.clone(),
        task_id: msg.task_id.clone(),
        context_id: msg.context_id.clone(),
    })
}

/// Convert a2a-types Artifact to WIT Artifact.
pub fn artifact_from_a2a(artifact: &a2a_types::Artifact) -> Result<Artifact, String> {
    let parts: Result<Vec<_>, _> = artifact.parts.iter().map(part_from_a2a).collect();

    Ok(Artifact {
        artifact_id: artifact.artifact_id.clone(),
        name: artifact.name.clone(),
        description: artifact.description.clone(),
        parts: parts?,
    })
}

/// Convert a2a-types TaskStatus to WIT TaskStatus.
pub fn task_status_from_a2a(status: &a2a_types::TaskStatus) -> Result<TaskStatus, String> {
    let message = match &status.message {
        Some(msg) => Some(message_from_a2a(msg)?),
        None => None,
    };

    Ok(TaskStatus {
        state: task_state_from_a2a(&status.state),
        message,
        // Convert DateTime<Utc> to RFC 3339 string
        timestamp: status.timestamp.map(|dt| dt.to_rfc3339()),
    })
}

/// Convert a2a-types Task to WIT Task.
pub fn task_from_a2a(task: &a2a_types::Task) -> Result<Task, String> {
    // a2a-types Task has history and artifacts as Vec (not Option<Vec>)
    // WIT Task has them as Option<list<...>>
    let history = if task.history.is_empty() {
        None
    } else {
        let converted: Result<Vec<_>, _> = task.history.iter().map(message_from_a2a).collect();
        Some(converted?)
    };

    let artifacts = if task.artifacts.is_empty() {
        None
    } else {
        let converted: Result<Vec<_>, _> = task.artifacts.iter().map(artifact_from_a2a).collect();
        Some(converted?)
    };

    Ok(Task {
        id: task.id.clone(),
        context_id: task.context_id.clone(),
        status: task_status_from_a2a(&task.status)?,
        history,
        artifacts,
    })
}

/// Convert WIT MessageSendConfig to a2a-types MessageSendConfiguration.
pub fn message_send_config_to_a2a(
    config: MessageSendConfig,
) -> a2a_types::MessageSendConfiguration {
    a2a_types::MessageSendConfiguration {
        accepted_output_modes: config.accepted_output_modes.unwrap_or_default(),
        history_length: config.history_length.map(|v| v as u64),
        blocking: config.blocking,
        push_notification_config: None,
    }
}

/// Convert WIT MessageSendParams to a2a-types MessageSendParams.
pub fn message_send_params_to_a2a(
    params: MessageSendParams,
) -> Result<a2a_types::MessageSendParams, String> {
    let configuration = params.configuration.map(message_send_config_to_a2a);

    Ok(a2a_types::MessageSendParams {
        message: message_to_a2a(params.message)?,
        configuration,
        metadata: Default::default(),
    })
}

/// Convert a2a-types SendMessageResponse to WIT SendResponse.
pub fn send_response_from_a2a(
    response: &a2a_types::SendMessageResponse,
) -> Result<SendResponse, String> {
    match response {
        a2a_types::SendMessageResponse::Task(task) => {
            Ok(SendResponse::Task(task_from_a2a(task)?))
        }
        a2a_types::SendMessageResponse::Message(msg) => {
            Ok(SendResponse::Message(message_from_a2a(msg)?))
        }
    }
}

/// Convert a String error to WIT Error.
pub fn error_from_string(msg: String) -> Error {
    Error {
        code: -32603, // Internal error
        message: msg,
    }
}

/// Convert a2a-types JsonrpcError to WIT Error.
pub fn error_from_a2a(err: &a2a_types::JsonrpcError) -> Error {
    Error {
        code: err.code as i32,
        message: err.message.clone(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_role_conversion() {
        assert!(matches!(role_to_a2a(Role::User), a2a_types::Role::User));
        assert!(matches!(role_to_a2a(Role::Agent), a2a_types::Role::Agent));
        assert!(matches!(role_from_a2a(&a2a_types::Role::User), Role::User));
        assert!(matches!(
            role_from_a2a(&a2a_types::Role::Agent),
            Role::Agent
        ));
    }

    #[test]
    fn test_task_state_conversion() {
        // Test all 9 states
        assert!(matches!(
            task_state_to_a2a(TaskState::Submitted),
            a2a_types::TaskState::Submitted
        ));
        assert!(matches!(
            task_state_to_a2a(TaskState::Working),
            a2a_types::TaskState::Working
        ));
        assert!(matches!(
            task_state_to_a2a(TaskState::InputRequired),
            a2a_types::TaskState::InputRequired
        ));
        assert!(matches!(
            task_state_to_a2a(TaskState::Completed),
            a2a_types::TaskState::Completed
        ));
        assert!(matches!(
            task_state_to_a2a(TaskState::Canceled),
            a2a_types::TaskState::Canceled
        ));
        assert!(matches!(
            task_state_to_a2a(TaskState::Failed),
            a2a_types::TaskState::Failed
        ));
        assert!(matches!(
            task_state_to_a2a(TaskState::Rejected),
            a2a_types::TaskState::Rejected
        ));
        assert!(matches!(
            task_state_to_a2a(TaskState::AuthRequired),
            a2a_types::TaskState::AuthRequired
        ));
        assert!(matches!(
            task_state_to_a2a(TaskState::Unknown),
            a2a_types::TaskState::Unknown
        ));
    }

    #[test]
    fn test_text_part_conversion() {
        let wit_part = Part::Text(TextPart {
            text: "hello".to_string(),
        });
        let a2a_part = part_to_a2a(wit_part).unwrap();
        assert!(matches!(a2a_part, a2a_types::Part::TextPart(_)));

        if let a2a_types::Part::TextPart(tp) = a2a_part {
            assert_eq!(tp.text, "hello");
        }
    }

    #[test]
    fn test_file_part_not_implemented() {
        let wit_part = Part::File(FilePart {
            file: FileContent {
                name: None,
                mime_type: None,
                uri: None,
                bytes: None,
            },
        });
        assert!(part_to_a2a(wit_part).is_err());
    }

    #[test]
    fn test_data_part_not_implemented() {
        let wit_part = Part::Data(DataPart {
            data: "{}".to_string(),
            mime_type: None,
        });
        assert!(part_to_a2a(wit_part).is_err());
    }
}
