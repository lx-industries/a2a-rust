// crates/a2a-types/build.rs
use std::env;
use std::fs;
use std::path::Path;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let schema_path = Path::new("schema/a2a.json");

    println!("cargo:rerun-if-changed=schema/a2a.json");

    let schema_content = fs::read_to_string(schema_path).expect("Failed to read schema file");

    let schema: schemars::schema::RootSchema =
        serde_json::from_str(&schema_content).expect("Failed to parse JSON schema");

    let mut settings = typify::TypeSpaceSettings::default();
    settings.with_derive("Clone".to_string());
    settings.with_derive("Debug".to_string());
    settings.with_derive("PartialEq".to_string());

    let mut type_space = typify::TypeSpace::new(&settings);
    type_space
        .add_root_schema(schema)
        .expect("Failed to process schema");

    let tokens = type_space.to_stream();
    let mut contents = format!("// Generated by build.rs - do not edit\n\n{}", tokens);

    // Remove the generated error module since we provide our own in src/error.rs
    // The generated error module pattern looks like:
    // #[doc = r" Error types."] pub mod error { ... }
    // We use regex-like string manipulation to remove it
    if let Some(start) = contents.find("# [doc = r\" Error types.\"] pub mod error {") {
        // Find the matching closing brace by counting braces
        let after_start = &contents[start..];
        let mut brace_count = 0;
        let mut end_offset = 0;
        let mut in_error_mod = false;

        for (i, c) in after_start.char_indices() {
            if c == '{' {
                if !in_error_mod {
                    in_error_mod = true;
                }
                brace_count += 1;
            } else if c == '}' {
                brace_count -= 1;
                if in_error_mod && brace_count == 0 {
                    end_offset = i + 1;
                    break;
                }
            }
        }

        if end_offset > 0 {
            contents = format!("{}{}", &contents[..start], &contents[start + end_offset..]);
        }
    }

    let dest_path = Path::new(&out_dir).join("generated_types.rs");
    fs::write(&dest_path, contents).expect("Failed to write generated types");
}
