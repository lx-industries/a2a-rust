// This file is @generated by prost-build.
/// --8<-- \[start:SendMessageConfiguration\]
/// Configuration of a send message request.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SendMessageConfiguration {
    /// A list of media types the client is prepared to accept for response parts. Agents SHOULD use this to tailor their output.
    #[prost(string, repeated, tag = "1")]
    pub accepted_output_modes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Configuration for the agent to send push notifications for task updates.
    #[prost(message, optional, tag = "2")]
    pub push_notification_config: ::core::option::Option<PushNotificationConfig>,
    /// The maximum number of messages to include in the history.
    #[prost(int32, optional, tag = "3")]
    pub history_length: ::core::option::Option<i32>,
    /// If true, the operation waits until the task reaches a terminal state before returning. Default is false.
    #[prost(bool, tag = "4")]
    pub blocking: bool,
}
/// --8<-- \[start:Task\]
/// Task is the core unit of action for A2A. It has a current status
/// and when results are created for the task they are stored in the
/// artifact. If there are multiple turns for a task, these are stored in
/// history.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Task {
    /// Unique identifier (e.g. UUID) for the task, generated by the server for a
    /// new task.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Unique identifier (e.g. UUID) for the contextual collection of interactions
    /// (tasks and messages). Created by the A2A server.
    #[prost(string, tag = "2")]
    pub context_id: ::prost::alloc::string::String,
    /// The current status of a Task, including state and a message.
    #[prost(message, optional, tag = "3")]
    pub status: ::core::option::Option<TaskStatus>,
    /// A set of output artifacts for a Task.
    #[prost(message, repeated, tag = "4")]
    pub artifacts: ::prost::alloc::vec::Vec<Artifact>,
    /// protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
    /// The history of interactions from a task.
    #[prost(message, repeated, tag = "5")]
    pub history: ::prost::alloc::vec::Vec<Message>,
    /// protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
    /// A key/value object to store custom metadata about a task.
    #[prost(message, optional, tag = "6")]
    pub metadata: ::core::option::Option<::prost_types::Struct>,
}
/// --8<-- \[start:TaskStatus\]
/// A container for the status of a task
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskStatus {
    /// The current state of this task.
    #[prost(enumeration = "TaskState", tag = "1")]
    pub state: i32,
    /// A message associated with the status.
    #[prost(message, optional, tag = "2")]
    pub message: ::core::option::Option<Message>,
    /// ISO 8601 Timestamp when the status was recorded.
    /// Example: "2023-10-27T10:00:00Z"
    #[prost(message, optional, tag = "3")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
}
/// --8<-- \[start:Part\]
/// Part represents a container for a section of communication content.
/// Parts can be purely textual, some sort of file (image, video, etc) or
/// a structured data blob (i.e. JSON).
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Part {
    /// Optional metadata associated with this part.
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<::prost_types::Struct>,
    #[prost(oneof = "part::Part", tags = "1, 2, 3")]
    pub part: ::core::option::Option<part::Part>,
}
/// Nested message and enum types in `Part`.
pub mod part {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Part {
        /// The string content of the text part.
        #[prost(string, tag = "1")]
        Text(::prost::alloc::string::String),
        /// The file content, represented as either a URI or as base64-encoded bytes.
        #[prost(message, tag = "2")]
        File(super::FilePart),
        /// The structured data content.
        #[prost(message, tag = "3")]
        Data(super::DataPart),
    }
}
/// --8<-- \[start:FilePart\]
/// FilePart represents the different ways files can be provided. If files are
/// small, directly feeding the bytes is supported via file_with_bytes. If the
/// file is large, the agent should read the content as appropriate directly
/// from the file_with_uri source.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FilePart {
    /// The media type of the file (e.g., "application/pdf").
    #[prost(string, tag = "3")]
    pub media_type: ::prost::alloc::string::String,
    /// An optional name for the file (e.g., "document.pdf").
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    #[prost(oneof = "file_part::File", tags = "1, 2")]
    pub file: ::core::option::Option<file_part::File>,
}
/// Nested message and enum types in `FilePart`.
pub mod file_part {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum File {
        /// A URL pointing to the file's content.
        #[prost(string, tag = "1")]
        FileWithUri(::prost::alloc::string::String),
        /// The base64-encoded content of the file.
        #[prost(bytes, tag = "2")]
        FileWithBytes(::prost::alloc::vec::Vec<u8>),
    }
}
/// --8<-- \[start:DataPart\]
/// DataPart represents a structured blob.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataPart {
    ///   A JSON object containing arbitrary data.
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<::prost_types::Struct>,
}
/// --8<-- \[start:Message\]
/// Message is one unit of communication between client and server. It can be
/// associated with a context and/or a task. For server messages, context_id must
/// be provided, and task_id only if a task was created. For client messages, both
/// fields are optional, with the caveat that if both are provided, they have to
/// match (the context_id has to be the one that is set on the task). If only
/// task_id is provided, the server will infer context_id from it.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Message {
    /// The unique identifier (e.g. UUID) of the message. This is required and
    /// created by the message creator.
    #[prost(string, tag = "1")]
    pub message_id: ::prost::alloc::string::String,
    /// The context id of the message. This is optional and if set, the message
    /// will be associated with the given context.
    #[prost(string, tag = "2")]
    pub context_id: ::prost::alloc::string::String,
    /// The task id of the message. This is optional and if set, the message
    /// will be associated with the given task.
    #[prost(string, tag = "3")]
    pub task_id: ::prost::alloc::string::String,
    /// Identifies the sender of the message.
    #[prost(enumeration = "Role", tag = "4")]
    pub role: i32,
    /// protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
    /// Parts is the container of the message content.
    #[prost(message, repeated, tag = "5")]
    pub parts: ::prost::alloc::vec::Vec<Part>,
    /// protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
    /// Any optional metadata to provide along with the message.
    #[prost(message, optional, tag = "6")]
    pub metadata: ::core::option::Option<::prost_types::Struct>,
    /// The URIs of extensions that are present or contributed to this Message.
    #[prost(string, repeated, tag = "7")]
    pub extensions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// A list of task IDs that this message references for additional context.
    #[prost(string, repeated, tag = "8")]
    pub reference_task_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// --8<-- \[start:Artifact\]
/// Artifacts represent task outputs.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Artifact {
    /// Unique identifier (e.g. UUID) for the artifact. It must be at least unique
    /// within a task.
    #[prost(string, tag = "1")]
    pub artifact_id: ::prost::alloc::string::String,
    /// A human readable name for the artifact.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// A human readable description of the artifact, optional.
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// The content of the artifact. Must contain at least one part.
    #[prost(message, repeated, tag = "5")]
    pub parts: ::prost::alloc::vec::Vec<Part>,
    /// Optional metadata included with the artifact.
    #[prost(message, optional, tag = "6")]
    pub metadata: ::core::option::Option<::prost_types::Struct>,
    /// The URIs of extensions that are present or contributed to this Artifact.
    #[prost(string, repeated, tag = "7")]
    pub extensions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// --8<-- \[start:TaskStatusUpdateEvent\]
/// An event sent by the agent to notify the client of a change in a task's
/// status.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskStatusUpdateEvent {
    /// The id of the task that is changed
    #[prost(string, tag = "1")]
    pub task_id: ::prost::alloc::string::String,
    /// The id of the context that the task belongs to
    #[prost(string, tag = "2")]
    pub context_id: ::prost::alloc::string::String,
    /// The new status of the task.
    #[prost(message, optional, tag = "3")]
    pub status: ::core::option::Option<TaskStatus>,
    /// If true, this is the final event in the stream for this interaction.
    #[prost(bool, tag = "4")]
    pub r#final: bool,
    /// Optional metadata to associate with the task update.
    #[prost(message, optional, tag = "5")]
    pub metadata: ::core::option::Option<::prost_types::Struct>,
}
/// --8<-- \[start:TaskArtifactUpdateEvent\]
/// TaskArtifactUpdateEvent represents a task delta where an artifact has
/// been generated.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskArtifactUpdateEvent {
    /// The id of the task for this artifact.
    #[prost(string, tag = "1")]
    pub task_id: ::prost::alloc::string::String,
    /// The id of the context that this task belongs to.
    #[prost(string, tag = "2")]
    pub context_id: ::prost::alloc::string::String,
    /// The artifact that was generated or updated.
    #[prost(message, optional, tag = "3")]
    pub artifact: ::core::option::Option<Artifact>,
    /// If true, the content of this artifact should be appended to a previously
    /// sent artifact with the same ID.
    #[prost(bool, tag = "4")]
    pub append: bool,
    /// If true, this is the final chunk of the artifact.
    #[prost(bool, tag = "5")]
    pub last_chunk: bool,
    /// Optional metadata associated with the artifact update.
    #[prost(message, optional, tag = "6")]
    pub metadata: ::core::option::Option<::prost_types::Struct>,
}
/// --8<-- \[start:PushNotificationConfig\]
/// Configuration for setting up push notifications for task updates.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PushNotificationConfig {
    /// A unique identifier (e.g. UUID) for this push notification.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Url to send the notification too
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    /// Token unique for this task/session
    #[prost(string, tag = "3")]
    pub token: ::prost::alloc::string::String,
    /// Information about the authentication to sent with the notification
    #[prost(message, optional, tag = "4")]
    pub authentication: ::core::option::Option<AuthenticationInfo>,
}
/// --8<-- \[start:PushNotificationAuthenticationInfo\]
/// Defines authentication details, used for push notifications.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AuthenticationInfo {
    /// A list of supported authentication schemes (e.g., 'Basic', 'Bearer').
    #[prost(string, repeated, tag = "1")]
    pub schemes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional credentials
    #[prost(string, tag = "2")]
    pub credentials: ::prost::alloc::string::String,
}
/// --8<-- \[start:AgentInterface\]
/// Declares a combination of a target URL and a transport protocol for interacting with the agent.
/// This allows agents to expose the same functionality over multiple protocol binding mechanisms.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AgentInterface {
    /// The URL where this interface is available. Must be a valid absolute HTTPS URL in production.
    /// Example: "<https://api.example.com/a2a/v1",> "<https://grpc.example.com/a2a">
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    /// The protocol binding supported at this URL. This is an open form string, to be
    /// easily extended for other protocol bindings. The core ones officially
    /// supported are `JSONRPC`, `GRPC` and `HTTP+JSON`.
    #[prost(string, tag = "2")]
    pub protocol_binding: ::prost::alloc::string::String,
    /// Tenant to be set in the request when calling the agent.
    #[prost(string, tag = "3")]
    pub tenant: ::prost::alloc::string::String,
}
/// --8<-- \[start:AgentCard\]
/// AgentCard is a self-describing manifest for an agent. It provides essential
/// metadata including the agent's identity, capabilities, skills, supported
/// communication methods, and security requirements.
/// Next ID: 20
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentCard {
    /// The version of the A2A protocol this agent supports.
    /// Default: "1.0"
    #[prost(string, optional, tag = "16")]
    pub protocol_version: ::core::option::Option<::prost::alloc::string::String>,
    /// A human readable name for the agent.
    /// Example: "Recipe Agent"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// A human-readable description of the agent, assisting users and other agents
    /// in understanding its purpose.
    /// Example: "Agent that helps users with recipes and cooking."
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// Ordered list of supported interfaces. First entry is preferred.
    #[prost(message, repeated, tag = "19")]
    pub supported_interfaces: ::prost::alloc::vec::Vec<AgentInterface>,
    /// DEPRECATED: Use 'supported_interfaces' instead.
    #[deprecated]
    #[prost(string, optional, tag = "3")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
    /// DEPRECATED: Use 'supported_interfaces' instead.
    #[deprecated]
    #[prost(string, optional, tag = "14")]
    pub preferred_transport: ::core::option::Option<::prost::alloc::string::String>,
    /// DEPRECATED: Use 'supported_interfaces' instead.
    #[deprecated]
    #[prost(message, repeated, tag = "15")]
    pub additional_interfaces: ::prost::alloc::vec::Vec<AgentInterface>,
    /// The service provider of the agent.
    #[prost(message, optional, tag = "4")]
    pub provider: ::core::option::Option<AgentProvider>,
    /// The version of the agent.
    /// Example: "1.0.0"
    #[prost(string, tag = "5")]
    pub version: ::prost::alloc::string::String,
    /// A url to provide additional documentation about the agent.
    #[prost(string, optional, tag = "6")]
    pub documentation_url: ::core::option::Option<::prost::alloc::string::String>,
    /// A2A Capability set supported by the agent.
    #[prost(message, optional, tag = "7")]
    pub capabilities: ::core::option::Option<AgentCapabilities>,
    /// The security scheme details used for authenticating with this agent.
    #[prost(map = "string, message", tag = "8")]
    pub security_schemes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        SecurityScheme,
    >,
    /// protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
    /// Security requirements for contacting the agent.
    #[prost(message, repeated, tag = "9")]
    pub security: ::prost::alloc::vec::Vec<Security>,
    /// protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
    /// The set of interaction modes that the agent supports across all skills.
    /// This can be overridden per skill. Defined as media types.
    #[prost(string, repeated, tag = "10")]
    pub default_input_modes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The media types supported as outputs from this agent.
    #[prost(string, repeated, tag = "11")]
    pub default_output_modes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Skills represent an ability of an agent. It is largely
    /// a descriptive concept but represents a more focused set of behaviors that the
    /// agent is likely to succeed at.
    #[prost(message, repeated, tag = "12")]
    pub skills: ::prost::alloc::vec::Vec<AgentSkill>,
    /// Whether the agent supports providing an extended agent card when authenticated.
    #[prost(bool, optional, tag = "13")]
    pub supports_extended_agent_card: ::core::option::Option<bool>,
    /// JSON Web Signatures computed for this AgentCard.
    #[prost(message, repeated, tag = "17")]
    pub signatures: ::prost::alloc::vec::Vec<AgentCardSignature>,
    /// An optional URL to an icon for the agent.
    #[prost(string, optional, tag = "18")]
    pub icon_url: ::core::option::Option<::prost::alloc::string::String>,
}
/// --8<-- \[start:AgentProvider\]
/// Represents the service provider of an agent.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AgentProvider {
    /// A URL for the agent provider's website or relevant documentation.
    /// Example: "<https://ai.google.dev">
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    /// The name of the agent provider's organization.
    /// Example: "Google"
    #[prost(string, tag = "2")]
    pub organization: ::prost::alloc::string::String,
}
/// --8<-- \[start:AgentCapabilities\]
/// Defines optional capabilities supported by an agent.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentCapabilities {
    /// Indicates if the agent supports streaming responses.
    #[prost(bool, optional, tag = "1")]
    pub streaming: ::core::option::Option<bool>,
    /// Indicates if the agent supports sending push notifications for asynchronous task updates.
    #[prost(bool, optional, tag = "2")]
    pub push_notifications: ::core::option::Option<bool>,
    /// A list of protocol extensions supported by the agent.
    #[prost(message, repeated, tag = "3")]
    pub extensions: ::prost::alloc::vec::Vec<AgentExtension>,
    /// Indicates if the agent provides a history of state transitions for a task.
    #[prost(bool, optional, tag = "4")]
    pub state_transition_history: ::core::option::Option<bool>,
}
/// --8<-- \[start:AgentExtension\]
/// A declaration of a protocol extension supported by an Agent.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentExtension {
    /// The unique URI identifying the extension.
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    /// A human-readable description of how this agent uses the extension.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// If true, the client must understand and comply with the extension's requirements.
    #[prost(bool, tag = "3")]
    pub required: bool,
    /// Optional, extension-specific configuration parameters.
    #[prost(message, optional, tag = "4")]
    pub params: ::core::option::Option<::prost_types::Struct>,
}
/// --8<-- \[start:AgentSkill\]
/// Represents a distinct capability or function that an agent can perform.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentSkill {
    /// A unique identifier for the agent's skill.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// A human-readable name for the skill.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// A detailed description of the skill.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// A set of keywords describing the skill's capabilities.
    #[prost(string, repeated, tag = "4")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Example prompts or scenarios that this skill can handle.
    #[prost(string, repeated, tag = "5")]
    pub examples: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The set of supported input media types for this skill, overriding the agent's defaults.
    #[prost(string, repeated, tag = "6")]
    pub input_modes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The set of supported output media types for this skill, overriding the agent's defaults.
    #[prost(string, repeated, tag = "7")]
    pub output_modes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
    /// Security schemes necessary for this skill.
    ///
    /// protolint:enable REPEATED_FIELD_NAMES_PLURALIZED
    #[prost(message, repeated, tag = "8")]
    pub security: ::prost::alloc::vec::Vec<Security>,
}
/// --8<-- \[start:AgentCardSignature\]
/// AgentCardSignature represents a JWS signature of an AgentCard.
/// This follows the JSON format of an RFC 7515 JSON Web Signature (JWS).
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentCardSignature {
    /// The protected JWS header for the signature. This is always a
    /// base64url-encoded JSON object. Required.
    #[prost(string, tag = "1")]
    pub protected: ::prost::alloc::string::String,
    /// The computed signature, base64url-encoded. Required.
    #[prost(string, tag = "2")]
    pub signature: ::prost::alloc::string::String,
    /// The unprotected JWS header values.
    #[prost(message, optional, tag = "3")]
    pub header: ::core::option::Option<::prost_types::Struct>,
}
/// --8<-- \[start:TaskPushNotificationConfig\]
/// A container associating a push notification configuration with a specific
/// task.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TaskPushNotificationConfig {
    /// The resource name of the config.
    /// Format: tasks/{task_id}/pushNotificationConfigs/{config_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The push notification configuration details.
    #[prost(message, optional, tag = "2")]
    pub push_notification_config: ::core::option::Option<PushNotificationConfig>,
}
/// protolint:disable REPEATED_FIELD_NAMES_PLURALIZED
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StringList {
    #[prost(string, repeated, tag = "1")]
    pub list: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Security {
    #[prost(map = "string, message", tag = "1")]
    pub schemes: ::std::collections::HashMap<::prost::alloc::string::String, StringList>,
}
/// --8<-- \[start:SecurityScheme\]
/// Defines a security scheme that can be used to secure an agent's endpoints.
/// This is a discriminated union type based on the OpenAPI 3.2 Security Scheme Object.
/// See: <https://spec.openapis.org/oas/v3.2.0.html#security-scheme-object>
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityScheme {
    #[prost(oneof = "security_scheme::Scheme", tags = "1, 2, 3, 4, 5")]
    pub scheme: ::core::option::Option<security_scheme::Scheme>,
}
/// Nested message and enum types in `SecurityScheme`.
pub mod security_scheme {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Scheme {
        /// API key-based authentication.
        #[prost(message, tag = "1")]
        ApiKeySecurityScheme(super::ApiKeySecurityScheme),
        /// HTTP authentication (Basic, Bearer, etc.).
        #[prost(message, tag = "2")]
        HttpAuthSecurityScheme(super::HttpAuthSecurityScheme),
        /// OAuth 2.0 authentication.
        #[prost(message, tag = "3")]
        Oauth2SecurityScheme(super::OAuth2SecurityScheme),
        /// OpenID Connect authentication.
        #[prost(message, tag = "4")]
        OpenIdConnectSecurityScheme(super::OpenIdConnectSecurityScheme),
        /// Mutual TLS authentication.
        #[prost(message, tag = "5")]
        MtlsSecurityScheme(super::MutualTlsSecurityScheme),
    }
}
/// --8<-- \[start:APIKeySecurityScheme\]
/// Defines a security scheme using an API key.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ApiKeySecurityScheme {
    /// An optional description for the security scheme.
    #[prost(string, tag = "1")]
    pub description: ::prost::alloc::string::String,
    /// The location of the API key. Valid values are "query", "header", or "cookie".
    #[prost(string, tag = "2")]
    pub location: ::prost::alloc::string::String,
    /// The name of the header, query, or cookie parameter to be used.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
/// --8<-- \[start:HTTPAuthSecurityScheme\]
/// Defines a security scheme using HTTP authentication.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HttpAuthSecurityScheme {
    /// An optional description for the security scheme.
    #[prost(string, tag = "1")]
    pub description: ::prost::alloc::string::String,
    /// The name of the HTTP Authentication scheme to be used in the Authorization header,
    /// as defined in RFC7235 (e.g., "Bearer").
    /// This value should be registered in the IANA Authentication Scheme registry.
    #[prost(string, tag = "2")]
    pub scheme: ::prost::alloc::string::String,
    /// A hint to the client to identify how the bearer token is formatted (e.g., "JWT").
    /// This is primarily for documentation purposes.
    #[prost(string, tag = "3")]
    pub bearer_format: ::prost::alloc::string::String,
}
/// --8<-- \[start:OAuth2SecurityScheme\]
/// Defines a security scheme using OAuth 2.0.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OAuth2SecurityScheme {
    /// An optional description for the security scheme.
    #[prost(string, tag = "1")]
    pub description: ::prost::alloc::string::String,
    /// An object containing configuration information for the supported OAuth 2.0 flows.
    #[prost(message, optional, tag = "2")]
    pub flows: ::core::option::Option<OAuthFlows>,
    /// URL to the oauth2 authorization server metadata
    /// RFC8414 (<https://datatracker.ietf.org/doc/html/rfc8414>). TLS is required.
    #[prost(string, tag = "3")]
    pub oauth2_metadata_url: ::prost::alloc::string::String,
}
/// --8<-- \[start:OpenIdConnectSecurityScheme\]
/// Defines a security scheme using OpenID Connect.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OpenIdConnectSecurityScheme {
    /// An optional description for the security scheme.
    #[prost(string, tag = "1")]
    pub description: ::prost::alloc::string::String,
    /// The OpenID Connect Discovery URL for the OIDC provider's metadata.
    /// See: <https://openid.net/specs/openid-connect-discovery-1_0.html>
    #[prost(string, tag = "2")]
    pub open_id_connect_url: ::prost::alloc::string::String,
}
/// --8<-- \[start:MutualTLSSecurityScheme\]
/// Defines a security scheme using mTLS authentication.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MutualTlsSecurityScheme {
    /// An optional description for the security scheme.
    #[prost(string, tag = "1")]
    pub description: ::prost::alloc::string::String,
}
/// --8<-- \[start:OAuthFlows\]
/// Defines the configuration for the supported OAuth 2.0 flows.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OAuthFlows {
    #[prost(oneof = "o_auth_flows::Flow", tags = "1, 2, 3, 4")]
    pub flow: ::core::option::Option<o_auth_flows::Flow>,
}
/// Nested message and enum types in `OAuthFlows`.
pub mod o_auth_flows {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Flow {
        /// Configuration for the OAuth Authorization Code flow.
        #[prost(message, tag = "1")]
        AuthorizationCode(super::AuthorizationCodeOAuthFlow),
        /// Configuration for the OAuth Client Credentials flow.
        #[prost(message, tag = "2")]
        ClientCredentials(super::ClientCredentialsOAuthFlow),
        /// Configuration for the OAuth Implicit flow.
        #[prost(message, tag = "3")]
        Implicit(super::ImplicitOAuthFlow),
        /// Configuration for the OAuth Resource Owner Password flow.
        #[prost(message, tag = "4")]
        Password(super::PasswordOAuthFlow),
    }
}
/// --8<-- \[start:AuthorizationCodeOAuthFlow\]
/// Defines configuration details for the OAuth 2.0 Authorization Code flow.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthorizationCodeOAuthFlow {
    /// The authorization URL to be used for this flow.
    #[prost(string, tag = "1")]
    pub authorization_url: ::prost::alloc::string::String,
    /// The token URL to be used for this flow.
    #[prost(string, tag = "2")]
    pub token_url: ::prost::alloc::string::String,
    /// The URL to be used for obtaining refresh tokens.
    #[prost(string, tag = "3")]
    pub refresh_url: ::prost::alloc::string::String,
    /// The available scopes for the OAuth2 security scheme.
    #[prost(map = "string, string", tag = "4")]
    pub scopes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// --8<-- \[start:ClientCredentialsOAuthFlow\]
/// Defines configuration details for the OAuth 2.0 Client Credentials flow.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientCredentialsOAuthFlow {
    /// The token URL to be used for this flow.
    #[prost(string, tag = "1")]
    pub token_url: ::prost::alloc::string::String,
    /// The URL to be used for obtaining refresh tokens.
    #[prost(string, tag = "2")]
    pub refresh_url: ::prost::alloc::string::String,
    /// The available scopes for the OAuth2 security scheme.
    #[prost(map = "string, string", tag = "3")]
    pub scopes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// --8<-- \[start:ImplicitOAuthFlow\]
/// Defines configuration details for the OAuth 2.0 Implicit flow.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImplicitOAuthFlow {
    /// The authorization URL to be used for this flow.
    #[prost(string, tag = "1")]
    pub authorization_url: ::prost::alloc::string::String,
    /// The URL to be used for obtaining refresh tokens.
    #[prost(string, tag = "2")]
    pub refresh_url: ::prost::alloc::string::String,
    /// The available scopes for the OAuth2 security scheme.
    #[prost(map = "string, string", tag = "3")]
    pub scopes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// --8<-- \[start:PasswordOAuthFlow\]
/// Defines configuration details for the OAuth 2.0 Resource Owner Password flow.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PasswordOAuthFlow {
    /// The token URL to be used for this flow.
    #[prost(string, tag = "1")]
    pub token_url: ::prost::alloc::string::String,
    /// The URL to be used for obtaining refresh tokens.
    #[prost(string, tag = "2")]
    pub refresh_url: ::prost::alloc::string::String,
    /// The available scopes for the OAuth2 security scheme.
    #[prost(map = "string, string", tag = "3")]
    pub scopes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// /////////// Request Messages ///////////
/// --8<-- \[start:SendMessageRequest\]
/// Represents a request for the `message/send` method.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendMessageRequest {
    /// Optional tenant, provided as a path parameter.
    #[prost(string, tag = "4")]
    pub tenant: ::prost::alloc::string::String,
    /// The message to send to the agent.
    #[prost(message, optional, tag = "1")]
    pub request: ::core::option::Option<Message>,
    /// Configuration for the send request.
    #[prost(message, optional, tag = "2")]
    pub configuration: ::core::option::Option<SendMessageConfiguration>,
    /// A flexible key-value map for passing additional context or parameters.
    #[prost(message, optional, tag = "3")]
    pub metadata: ::core::option::Option<::prost_types::Struct>,
}
/// --8<-- \[start:GetTaskRequest\]
/// Represents a request for the `tasks/get` method.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTaskRequest {
    /// Optional tenant, provided as a path parameter.
    #[prost(string, tag = "3")]
    pub tenant: ::prost::alloc::string::String,
    /// The resource name of the task.
    /// Format: tasks/{task_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The maximum number of messages to include in the history.
    #[prost(int32, optional, tag = "2")]
    pub history_length: ::core::option::Option<i32>,
}
/// --8<-- \[start:ListTasksRequest\]
/// Parameters for listing tasks with optional filtering criteria.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListTasksRequest {
    /// Optional tenant, provided as a path parameter.
    #[prost(string, tag = "9")]
    pub tenant: ::prost::alloc::string::String,
    /// Filter tasks by context ID to get tasks from a specific conversation or session.
    #[prost(string, tag = "1")]
    pub context_id: ::prost::alloc::string::String,
    /// Filter tasks by their current status state.
    #[prost(enumeration = "TaskState", tag = "2")]
    pub status: i32,
    /// Maximum number of tasks to return. Must be between 1 and 100.
    /// Defaults to 50 if not specified.
    #[prost(int32, optional, tag = "3")]
    pub page_size: ::core::option::Option<i32>,
    /// Token for pagination. Use the next_page_token from a previous ListTasksResponse.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    /// The maximum number of messages to include in each task's history.
    #[prost(int32, optional, tag = "5")]
    pub history_length: ::core::option::Option<i32>,
    /// Filter tasks updated after this timestamp (milliseconds since epoch).
    /// Only tasks with a last updated time greater than or equal to this value will be returned.
    #[prost(int64, tag = "6")]
    pub last_updated_after: i64,
    /// Whether to include artifacts in the returned tasks.
    /// Defaults to false to reduce payload size.
    #[prost(bool, optional, tag = "7")]
    pub include_artifacts: ::core::option::Option<bool>,
}
/// --8<-- \[start:ListTasksResponse\]
/// Result object for tasks/list method containing an array of tasks and pagination information.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTasksResponse {
    /// Array of tasks matching the specified criteria.
    #[prost(message, repeated, tag = "1")]
    pub tasks: ::prost::alloc::vec::Vec<Task>,
    /// Token for retrieving the next page. Empty string if no more results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// The size of page requested.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Total number of tasks available (before pagination).
    #[prost(int32, tag = "4")]
    pub total_size: i32,
}
/// --8<-- \[start:CancelTaskRequest\]
/// Represents a request for the `tasks/cancel` method.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CancelTaskRequest {
    /// Optional tenant, provided as a path parameter.
    #[prost(string, tag = "2")]
    pub tenant: ::prost::alloc::string::String,
    /// The resource name of the task to cancel.
    /// Format: tasks/{task_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// --8<-- \[start:GetTaskPushNotificationConfigRequest\]
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTaskPushNotificationConfigRequest {
    /// Optional tenant, provided as a path parameter.
    #[prost(string, tag = "2")]
    pub tenant: ::prost::alloc::string::String,
    /// The resource name of the config to retrieve.
    /// Format: tasks/{task_id}/pushNotificationConfigs/{config_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// --8<-- \[start:DeleteTaskPushNotificationConfigRequest\]
/// Represents a request for the `tasks/pushNotificationConfig/delete` method.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteTaskPushNotificationConfigRequest {
    /// Optional tenant, provided as a path parameter.
    #[prost(string, tag = "2")]
    pub tenant: ::prost::alloc::string::String,
    /// The resource name of the config to delete.
    /// Format: tasks/{task_id}/pushNotificationConfigs/{config_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// --8<-- \[start:SetTaskPushNotificationConfigRequest\]
/// Represents a request for the `tasks/pushNotificationConfig/set` method.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetTaskPushNotificationConfigRequest {
    /// Optional tenant, provided as a path parameter.
    #[prost(string, tag = "4")]
    pub tenant: ::prost::alloc::string::String,
    /// The parent task resource for this config.
    /// Format: tasks/{task_id}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The ID for the new config.
    #[prost(string, tag = "2")]
    pub config_id: ::prost::alloc::string::String,
    /// The configuration to create.
    #[prost(message, optional, tag = "3")]
    pub config: ::core::option::Option<TaskPushNotificationConfig>,
}
/// --8<-- \[start:SubscribeToTaskRequest\]
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SubscribeToTaskRequest {
    /// Optional tenant, provided as a path parameter.
    #[prost(string, tag = "2")]
    pub tenant: ::prost::alloc::string::String,
    /// The resource name of the task to subscribe to.
    /// Format: tasks/{task_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// --8<-- \[start:ListTaskPushNotificationConfigRequest\]
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListTaskPushNotificationConfigRequest {
    /// Optional tenant, provided as a path parameter.
    #[prost(string, tag = "4")]
    pub tenant: ::prost::alloc::string::String,
    /// The parent task resource.
    /// Format: tasks/{task_id}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of configurations to return.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A page token received from a previous ListTaskPushNotificationConfigRequest call.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// --8<-- \[start:GetExtendedAgentCardRequest\]
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetExtendedAgentCardRequest {
    /// Optional tenant, provided as a path parameter.
    #[prost(string, tag = "1")]
    pub tenant: ::prost::alloc::string::String,
}
/// ////// Response Messages ///////////
/// --8<-- \[start:SendMessageResponse\]
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendMessageResponse {
    #[prost(oneof = "send_message_response::Payload", tags = "1, 2")]
    pub payload: ::core::option::Option<send_message_response::Payload>,
}
/// Nested message and enum types in `SendMessageResponse`.
pub mod send_message_response {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "1")]
        Task(super::Task),
        #[prost(message, tag = "2")]
        Msg(super::Message),
    }
}
/// --8<-- \[start:StreamResponse\]
/// A wrapper object used in streaming operations to encapsulate different types of response data.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamResponse {
    #[prost(oneof = "stream_response::Payload", tags = "1, 2, 3, 4")]
    pub payload: ::core::option::Option<stream_response::Payload>,
}
/// Nested message and enum types in `StreamResponse`.
pub mod stream_response {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        /// A Task object containing the current state of the task.
        #[prost(message, tag = "1")]
        Task(super::Task),
        /// A Message object containing a message from the agent.
        #[prost(message, tag = "2")]
        Msg(super::Message),
        /// An event indicating a task status update.
        #[prost(message, tag = "3")]
        StatusUpdate(super::TaskStatusUpdateEvent),
        /// An event indicating a task artifact update.
        #[prost(message, tag = "4")]
        ArtifactUpdate(super::TaskArtifactUpdateEvent),
    }
}
/// --8<-- \[start:ListTaskPushNotificationConfigResponse\]
/// Represents a successful response for the `tasks/pushNotificationConfig/list`
/// method.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTaskPushNotificationConfigResponse {
    /// The list of push notification configurations.
    #[prost(message, repeated, tag = "1")]
    pub configs: ::prost::alloc::vec::Vec<TaskPushNotificationConfig>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// --8<-- \[start:TaskState\]
/// Defines the possible lifecycle states of a Task.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TaskState {
    /// The task is in an unknown or indeterminate state.
    Unspecified = 0,
    /// Represents the status that acknowledges a task is created.
    Submitted = 1,
    /// Represents the status that a task is actively being processed.
    Working = 2,
    /// Represents the status a task is finished. This is a terminal state.
    Completed = 3,
    /// Represents the status a task is done but failed. This is a terminal state.
    Failed = 4,
    /// Represents the status a task was cancelled before it finished.
    /// This is a terminal state.
    Cancelled = 5,
    /// Represents the status that the task requires information to complete.
    /// This is an interrupted state.
    InputRequired = 6,
    /// Represents the status that the agent has decided to not perform the task.
    /// This may be done during initial task creation or later once an agent
    /// has determined it can't or won't proceed. This is a terminal state.
    Rejected = 7,
    /// Represents the state that some authentication is needed from the upstream
    /// client. Authentication is expected to come out-of-band thus this is not
    /// an interrupted or terminal state.
    AuthRequired = 8,
}
impl TaskState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TASK_STATE_UNSPECIFIED",
            Self::Submitted => "TASK_STATE_SUBMITTED",
            Self::Working => "TASK_STATE_WORKING",
            Self::Completed => "TASK_STATE_COMPLETED",
            Self::Failed => "TASK_STATE_FAILED",
            Self::Cancelled => "TASK_STATE_CANCELLED",
            Self::InputRequired => "TASK_STATE_INPUT_REQUIRED",
            Self::Rejected => "TASK_STATE_REJECTED",
            Self::AuthRequired => "TASK_STATE_AUTH_REQUIRED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TASK_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "TASK_STATE_SUBMITTED" => Some(Self::Submitted),
            "TASK_STATE_WORKING" => Some(Self::Working),
            "TASK_STATE_COMPLETED" => Some(Self::Completed),
            "TASK_STATE_FAILED" => Some(Self::Failed),
            "TASK_STATE_CANCELLED" => Some(Self::Cancelled),
            "TASK_STATE_INPUT_REQUIRED" => Some(Self::InputRequired),
            "TASK_STATE_REJECTED" => Some(Self::Rejected),
            "TASK_STATE_AUTH_REQUIRED" => Some(Self::AuthRequired),
            _ => None,
        }
    }
}
/// --8<-- \[start:Role\]
/// Defines the sender of a message in A2A protocol communication.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Role {
    Unspecified = 0,
    /// USER role refers to communication from the client to the server.
    User = 1,
    /// AGENT role refers to communication from the server to the client.
    Agent = 2,
}
impl Role {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ROLE_UNSPECIFIED",
            Self::User => "ROLE_USER",
            Self::Agent => "ROLE_AGENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ROLE_UNSPECIFIED" => Some(Self::Unspecified),
            "ROLE_USER" => Some(Self::User),
            "ROLE_AGENT" => Some(Self::Agent),
            _ => None,
        }
    }
}
