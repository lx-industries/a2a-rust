# WASM Server Integration Tests Design

**Goal:** Test the WASM component's HTTP server (`wasi:http/incoming-handler`) using the Python A2A SDK client.

**Architecture:** Rust test harness runs WASM component as HTTP server, Python client tests against it.

---

## Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                     Integration Test                             │
├─────────────────────────────────────────────────────────────────┤
│  1. Rust test starts WasmServer (port 9998)                     │
│  2. Rust test spawns Python client tests via uv                 │
│  3. Python tests use A2A SDK to call WASM server                │
│  4. WasmServer routes HTTP → incoming-handler → mock agent      │
└─────────────────────────────────────────────────────────────────┘

┌──────────────┐     HTTP      ┌──────────────────────────────────┐
│ Python A2A   │ ──────────►   │ WasmServer (Rust test harness)   │
│ SDK Client   │               │                                  │
└──────────────┘               │  ┌────────────────────────────┐  │
                               │  │ WASM Component             │  │
                               │  │  - incoming-handler        │  │
                               │  │  - imports mock agent      │  │
                               │  └────────────────────────────┘  │
                               │                                  │
                               │  ┌────────────────────────────┐  │
                               │  │ StatefulMockAgent          │  │
                               │  │  - task storage (HashMap)  │  │
                               │  │  - on_message → create     │  │
                               │  │  - on_get_task → retrieve  │  │
                               │  │  - on_cancel_task → cancel │  │
                               │  └────────────────────────────┘  │
                               └──────────────────────────────────┘
```

---

## HTTP Server Approach

**Why hyper?** `wasmtime-wasi-http` provides WASI HTTP bindings and type conversions, but not a built-in HTTP server. The crate's documentation explicitly shows using hyper for the server loop. This is by design—it gives embedders flexibility over networking.

**Pre-instantiation pattern:** Following wasmtime-wasi-http's recommended pattern, we use `A2aComponentPre` (generated by `bindgen!`) to pre-compile and validate the component once at startup. Per-request instantiation is then much faster since validation is already done.

---

## Components

### WasmServer (`tests/common/wasm_server.rs`)

```rust
/// Shared server state with pre-instantiated component
struct ServerState {
    engine: Engine,
    component_pre: A2aComponentPre<ServerClientState>,
    task_store: Arc<Mutex<TaskStore>>,
}

pub struct WasmServer {
    shutdown_tx: Option<oneshot::Sender<()>>,
    handle: tokio::task::JoinHandle<()>,
    pub url: String,
}

impl WasmServer {
    pub async fn start() -> Self {
        // 1. Create engine with async + component model
        let engine = Engine::new(&config)?;

        // 2. Load and pre-instantiate component (validates once)
        let component = Component::from_file(&engine, WASM_PATH)?;
        let mut linker = Linker::<ServerClientState>::new(&engine);
        wasmtime_wasi::add_to_linker_async(&mut linker)?;
        wasmtime_wasi_http::add_only_http_to_linker_async(&mut linker)?;
        a2a::protocol::agent::add_to_linker(&mut linker, |s| s)?;

        let component_pre = A2aComponentPre::new(&mut store, &component)?;

        // 3. Start hyper server on localhost:9998
        // 4. For each request:
        //    - Create fresh Store with ServerClientState
        //    - component_pre.instantiate_async(&mut store)
        //    - Call incoming_handler.call_handle()
    }
}
```

Port 9998 avoids collision with Python helloworld server (9999).

### Per-Request Handler

```rust
async fn handle_request(
    server_state: Arc<ServerState>,
    req: Request<Incoming>,
) -> Result<Response<HyperOutgoingBody>, hyper::Error> {
    // Fresh state per request
    let state = ServerClientState {
        wasi: WasiCtxBuilder::new().inherit_env().build(),
        http: WasiHttpCtx::new(),
        table: ResourceTable::new(),
        task_store: server_state.task_store.clone(),
    };
    let mut store = Store::new(&server_state.engine, state);

    // Fast instantiation from pre-validated component
    let (bindings, _instance) = server_state
        .component_pre
        .instantiate_async(&mut store)
        .await?;

    // Convert hyper request to WASI types
    let (sender, receiver) = oneshot::channel();
    let incoming = store.data_mut().new_incoming_request(Scheme::Http, req)?;
    let outparam = store.data_mut().new_response_outparam(sender)?;

    // Call the component's incoming-handler export
    bindings
        .wasi_http_incoming_handler()
        .call_handle(&mut store, incoming, outparam)
        .await?;

    // Response comes back through the channel
    receiver.await.unwrap()
}
```

### StatefulMockAgent

```rust
struct TaskStore {
    tasks: HashMap<String, Task>,
}

impl TaskStore {
    fn create_task(&mut self, message: &Message) -> Task {
        let id = uuid::Uuid::new_v4().to_string();
        let task = Task {
            id: id.clone(),
            context_id: message.context_id.clone()
                .unwrap_or_else(|| uuid::Uuid::new_v4().to_string()),
            status: TaskStatus {
                state: TaskState::Completed,
                message: Some(Message {
                    role: Role::Agent,
                    parts: vec![Part::Text(TextPart { text: "Hello World".into() })],
                    ..
                }),
                timestamp: Some(now_iso8601()),
            },
            history: None,
            artifacts: None,
        };
        self.tasks.insert(id, task.clone());
        task
    }

    fn get_task(&self, id: &str) -> Option<Task> { ... }

    fn cancel_task(&mut self, id: &str) -> Option<Task> {
        // Set state to Canceled, return task
    }
}
```

### Python Test Fixture (`tests/fixtures/wasm_server_tests/`)

```
wasm_server_tests/
├── pyproject.toml      # a2a-sdk dependency, pytest
├── test_wasm_server.py # Test cases
└── conftest.py         # pytest fixtures (server URL from env)
```

`pyproject.toml`:
```toml
[project]
name = "wasm-server-tests"
dependencies = [
    "a2a-sdk @ git+https://github.com/muscariello/a2a-python@a2a_proto_refactor",
    "pytest",
    "pytest-asyncio",
]
```

### Rust Integration Test

```rust
#[tokio::test]
async fn test_wasm_server_with_python_client() {
    // 1. Start WASM server
    let server = WasmServer::start().await;

    // 2. Run Python tests via uv
    let status = Command::new("uv")
        .args(["run", "pytest", "-v"])
        .current_dir("tests/fixtures/wasm_server_tests")
        .env("WASM_SERVER_URL", &server.url)
        .status()
        .expect("Failed to run pytest");

    assert!(status.success(), "Python tests failed");
}
```

---

## Test Coverage

| Test | Endpoint | Validates |
|------|----------|-----------|
| `test_agent_card_discovery` | `GET /.well-known/agent-card.json` | Discovery endpoint |
| `test_send_message_jsonrpc` | `POST /` (JSON-RPC) | SendMessage routing |
| `test_send_message_rest` | `POST /v1/message:send` | REST binding |
| `test_get_task_jsonrpc` | `POST /` (JSON-RPC) | GetTask routing |
| `test_get_task_rest` | `GET /v1/tasks/{id}` | REST binding |
| `test_get_task_not_found` | Both bindings | 404/error handling |
| `test_cancel_task_jsonrpc` | `POST /` (JSON-RPC) | CancelTask routing |
| `test_cancel_task_rest` | `POST /v1/tasks/{id}:cancel` | REST binding |
| `test_invalid_method` | `POST /` | JSON-RPC error -32601 |

---

## Dependencies

Rust (dev-dependencies):
- `wasmtime`, `wasmtime-wasi`, `wasmtime-wasi-http` 29.x (already present)
- `hyper` 1.8 with `server`, `http1` features (new)
- `http-body-util` 0.1 (new)
- `uuid` 1.x with `v4` feature (new)
- `chrono` 0.4 (new)
- `tokio` 1.48 (already present)

Python:
- `a2a-sdk` (proto_refactor branch)
- `pytest`, `pytest-asyncio`
