# A2A Rust SDK Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement a complete A2A protocol SDK in Rust targeting WASM (WASIP3) and Linux x86_64.

**Architecture:** Workspace with 6 core crates: types (generated), transport traits, WASI transport, client, server, and WASM component. Cross-implementation testing against JS/Python SDKs.

**Tech Stack:** Rust (latest stable), typify for code generation, wasi/wasip3 crates for WASM, serde for JSON.

---

## Task 1: Workspace Setup

**Files:**
- Create: `Cargo.toml` (workspace root)
- Create: `crates/a2a-types/Cargo.toml`
- Create: `crates/a2a-types/src/lib.rs`
- Create: `.gitignore`

**Step 1: Create workspace Cargo.toml**

```toml
[workspace]
resolver = "2"
members = [
    "crates/a2a-types",
    "crates/a2a-transport",
    "crates/a2a-transport-wasi",
    "crates/a2a-client",
    "crates/a2a-server",
    "crates/a2a-wasm-component",
]

[workspace.package]
version = "0.1.0"
edition = "2024"
license = "MIT OR Apache-2.0"
repository = "https://gitlab.com/lx-industries/a2a-rust"

[workspace.dependencies]
# Internal crates
a2a-types = { path = "crates/a2a-types" }
a2a-transport = { path = "crates/a2a-transport" }
a2a-transport-wasi = { path = "crates/a2a-transport-wasi" }
a2a-client = { path = "crates/a2a-client" }
a2a-server = { path = "crates/a2a-server" }

# Core dependencies
serde = { version = "1.0.228", features = ["derive"] }
serde_json = "1.0.148"
thiserror = "2.0.17"
futures-core = "0.3.31"
bytes = "1.11.0"

# Build dependencies
typify = "0.5.0"
schemars = "0.8"

# WASM dependencies
wasi = "0.14.7"
wit-bindgen = "0.50.0"
```

**Step 2: Create a2a-types crate scaffold**

```toml
# crates/a2a-types/Cargo.toml
[package]
name = "a2a-types"
version.workspace = true
edition.workspace = true
license.workspace = true

[dependencies]
serde.workspace = true
serde_json.workspace = true

[build-dependencies]
typify.workspace = true
schemars.workspace = true
serde_json.workspace = true
```

```rust
// crates/a2a-types/src/lib.rs
//! A2A Protocol type definitions.

pub mod error;

// Generated types will be included here
```

**Step 3: Create .gitignore**

```
/target
Cargo.lock
*.swp
*.swo
.DS_Store
```

**Step 4: Verify workspace builds**

Run: `cargo check`
Expected: Success (empty crates compile)

**Step 5: Commit**

```bash
git add Cargo.toml crates/ .gitignore
git commit -m "feat: initialize workspace with a2a-types crate scaffold"
```

---

## Task 2: Fetch A2A JSON Schema

**Files:**
- Create: `crates/a2a-types/schema/a2a.json`

**Step 1: Download the A2A JSON Schema from Python SDK**

The official schema is generated from protobuf at build time and not committed.
We'll extract the schema from the Python types or create one based on the specification.

Run: `mkdir -p crates/a2a-types/schema`

**Step 2: Create JSON Schema based on A2A spec**

Create `crates/a2a-types/schema/a2a.json` with the core types from the specification.
This is a large file - see the A2A protocol definitions for the complete schema.

Note: In practice, you may need to:
1. Generate from the proto definitions
2. Use the Python SDK's generated types as reference
3. Hand-write based on the specification

**Step 3: Commit**

```bash
git add crates/a2a-types/schema/
git commit -m "feat(a2a-types): add A2A JSON schema"
```

---

## Task 3: Implement a2a-types Code Generation

**Files:**
- Create: `crates/a2a-types/build.rs`
- Modify: `crates/a2a-types/src/lib.rs`

**Step 1: Write build.rs for typify code generation**

```rust
// crates/a2a-types/build.rs
use std::env;
use std::fs;
use std::path::Path;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let schema_path = Path::new("schema/a2a.json");

    println!("cargo:rerun-if-changed=schema/a2a.json");

    let schema_content = fs::read_to_string(schema_path)
        .expect("Failed to read schema file");

    let schema: schemars::schema::RootSchema = serde_json::from_str(&schema_content)
        .expect("Failed to parse JSON schema");

    let mut settings = typify::TypeSpaceSettings::default();
    settings.with_derive("Clone".to_string());
    settings.with_derive("Debug".to_string());
    settings.with_derive("PartialEq".to_string());

    let type_space = typify::TypeSpace::new(&settings)
        .add_root_schema(schema)
        .expect("Failed to process schema");

    let tokens = type_space.to_stream();
    let contents = format!(
        "// Generated by build.rs - do not edit\n\n{}",
        tokens
    );

    let dest_path = Path::new(&out_dir).join("generated_types.rs");
    fs::write(&dest_path, contents).expect("Failed to write generated types");
}
```

**Step 2: Include generated types in lib.rs**

```rust
// crates/a2a-types/src/lib.rs
//! A2A Protocol type definitions.

pub mod error;

// Include generated types
include!(concat!(env!("OUT_DIR"), "/generated_types.rs"));
```

**Step 3: Verify build works**

Run: `cargo build -p a2a-types`
Expected: Success with generated types

**Step 4: Commit**

```bash
git add crates/a2a-types/build.rs crates/a2a-types/src/lib.rs
git commit -m "feat(a2a-types): implement typify code generation"
```

---

## Task 4: Implement a2a-types Error Module

**Files:**
- Create: `crates/a2a-types/src/error.rs`

**Step 1: Write error types**

```rust
// crates/a2a-types/src/error.rs
use thiserror::Error;

#[derive(Debug, Error)]
pub enum Error {
    #[error("JSON serialization error: {0}")]
    Json(#[from] serde_json::Error),

    #[error("Invalid message: {0}")]
    InvalidMessage(String),

    #[error("Invalid task state: {0}")]
    InvalidTaskState(String),

    #[error("Invalid part type: {0}")]
    InvalidPartType(String),
}

pub type Result<T> = std::result::Result<T, Error>;
```

**Step 2: Update Cargo.toml for thiserror**

```toml
# Add to crates/a2a-types/Cargo.toml [dependencies]
thiserror.workspace = true
```

**Step 3: Verify build**

Run: `cargo build -p a2a-types`
Expected: Success

**Step 4: Commit**

```bash
git add crates/a2a-types/
git commit -m "feat(a2a-types): add error types"
```

---

## Task 5: Create a2a-transport Crate

**Files:**
- Create: `crates/a2a-transport/Cargo.toml`
- Create: `crates/a2a-transport/src/lib.rs`
- Create: `crates/a2a-transport/src/error.rs`
- Create: `crates/a2a-transport/src/types.rs`

**Step 1: Create Cargo.toml**

```toml
[package]
name = "a2a-transport"
version.workspace = true
edition.workspace = true
license.workspace = true

[dependencies]
thiserror.workspace = true
futures-core.workspace = true
bytes.workspace = true
```

**Step 2: Create types.rs with HTTP types**

```rust
// crates/a2a-transport/src/types.rs
use bytes::Bytes;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Method {
    Get,
    Post,
    Put,
    Delete,
}

impl Method {
    pub fn as_str(&self) -> &'static str {
        match self {
            Method::Get => "GET",
            Method::Post => "POST",
            Method::Put => "PUT",
            Method::Delete => "DELETE",
        }
    }
}

#[derive(Debug, Clone)]
pub struct HttpRequest {
    pub method: Method,
    pub url: String,
    pub headers: Vec<(String, String)>,
    pub body: Option<Bytes>,
}

impl HttpRequest {
    pub fn get(url: impl Into<String>) -> Self {
        Self {
            method: Method::Get,
            url: url.into(),
            headers: Vec::new(),
            body: None,
        }
    }

    pub fn post(url: impl Into<String>, body: impl Into<Bytes>) -> Self {
        Self {
            method: Method::Post,
            url: url.into(),
            headers: Vec::new(),
            body: Some(body.into()),
        }
    }

    pub fn with_header(mut self, name: impl Into<String>, value: impl Into<String>) -> Self {
        self.headers.push((name.into(), value.into()));
        self
    }
}

#[derive(Debug, Clone)]
pub struct HttpResponse {
    pub status: u16,
    pub headers: Vec<(String, String)>,
    pub body: Bytes,
}

impl HttpResponse {
    pub fn ok(body: impl Into<Bytes>) -> Self {
        Self {
            status: 200,
            headers: Vec::new(),
            body: body.into(),
        }
    }

    pub fn with_status(mut self, status: u16) -> Self {
        self.status = status;
        self
    }

    pub fn with_header(mut self, name: impl Into<String>, value: impl Into<String>) -> Self {
        self.headers.push((name.into(), value.into()));
        self
    }

    pub fn header(&self, name: &str) -> Option<&str> {
        self.headers
            .iter()
            .find(|(n, _)| n.eq_ignore_ascii_case(name))
            .map(|(_, v)| v.as_str())
    }
}
```

**Step 3: Create error.rs**

```rust
// crates/a2a-transport/src/error.rs
use thiserror::Error;

#[derive(Debug, Error)]
pub enum Error {
    #[error("HTTP error: status {status}")]
    Http {
        status: u16,
        body: Option<String>,
    },

    #[error("Connection error: {0}")]
    Connection(String),

    #[error("Timeout")]
    Timeout,

    #[error("Invalid URL: {0}")]
    InvalidUrl(String),
}

pub type Result<T> = std::result::Result<T, Error>;
```

**Step 4: Create lib.rs with traits**

```rust
// crates/a2a-transport/src/lib.rs
//! A2A transport traits and HTTP types.

pub mod error;
pub mod types;

pub use error::{Error, Result};
pub use types::{HttpRequest, HttpResponse, Method};

use bytes::Bytes;
use futures_core::Stream;
use std::future::Future;

/// HTTP client trait for making outgoing requests.
pub trait HttpClient: Send + Sync {
    /// Error type for this client.
    type Error: std::error::Error + Send + Sync + 'static;

    /// Send a request and receive a complete response.
    fn request(
        &self,
        request: HttpRequest,
    ) -> impl Future<Output = std::result::Result<HttpResponse, Self::Error>> + Send;

    /// Send a request and receive a streaming response.
    fn request_stream(
        &self,
        request: HttpRequest,
    ) -> impl Future<
        Output = std::result::Result<
            impl Stream<Item = std::result::Result<Bytes, Self::Error>> + Send,
            Self::Error,
        >,
    > + Send;
}

/// HTTP server trait for handling incoming requests.
pub trait HttpServer: Send + Sync {
    /// Error type for this server.
    type Error: std::error::Error + Send + Sync + 'static;

    /// Start serving requests, calling the handler for each one.
    fn serve<H, F>(
        &self,
        handler: H,
    ) -> impl Future<Output = std::result::Result<(), Self::Error>> + Send
    where
        H: Fn(HttpRequest) -> F + Send + Sync + 'static,
        F: Future<Output = HttpResponse> + Send;
}
```

**Step 5: Verify build**

Run: `cargo build -p a2a-transport`
Expected: Success

**Step 6: Commit**

```bash
git add crates/a2a-transport/
git commit -m "feat(a2a-transport): add HTTP transport traits and types"
```

---

## Task 6: Add Unit Tests for a2a-transport

**Files:**
- Create: `crates/a2a-transport/src/types.rs` (add tests)

**Step 1: Add tests to types.rs**

```rust
// Add to bottom of crates/a2a-transport/src/types.rs

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_http_request_get() {
        let req = HttpRequest::get("https://example.com");
        assert_eq!(req.method, Method::Get);
        assert_eq!(req.url, "https://example.com");
        assert!(req.body.is_none());
    }

    #[test]
    fn test_http_request_post() {
        let req = HttpRequest::post("https://example.com", b"hello".as_slice());
        assert_eq!(req.method, Method::Post);
        assert!(req.body.is_some());
    }

    #[test]
    fn test_http_request_with_header() {
        let req = HttpRequest::get("https://example.com")
            .with_header("Content-Type", "application/json");
        assert_eq!(req.headers.len(), 1);
        assert_eq!(req.headers[0], ("Content-Type".to_string(), "application/json".to_string()));
    }

    #[test]
    fn test_http_response_header_lookup() {
        let resp = HttpResponse::ok(b"test".as_slice())
            .with_header("Content-Type", "application/json")
            .with_header("X-Custom", "value");

        assert_eq!(resp.header("content-type"), Some("application/json"));
        assert_eq!(resp.header("Content-Type"), Some("application/json"));
        assert_eq!(resp.header("x-custom"), Some("value"));
        assert_eq!(resp.header("missing"), None);
    }

    #[test]
    fn test_method_as_str() {
        assert_eq!(Method::Get.as_str(), "GET");
        assert_eq!(Method::Post.as_str(), "POST");
        assert_eq!(Method::Put.as_str(), "PUT");
        assert_eq!(Method::Delete.as_str(), "DELETE");
    }
}
```

**Step 2: Run tests**

Run: `cargo test -p a2a-transport`
Expected: All tests pass

**Step 3: Commit**

```bash
git add crates/a2a-transport/
git commit -m "test(a2a-transport): add unit tests for HTTP types"
```

---

## Task 7: Create a2a-transport-wasi Crate Scaffold

**Files:**
- Create: `crates/a2a-transport-wasi/Cargo.toml`
- Create: `crates/a2a-transport-wasi/src/lib.rs`
- Create: `crates/a2a-transport-wasi/src/error.rs`

**Step 1: Create Cargo.toml**

```toml
[package]
name = "a2a-transport-wasi"
version.workspace = true
edition.workspace = true
license.workspace = true

[dependencies]
a2a-transport.workspace = true
thiserror.workspace = true
futures-core.workspace = true
bytes.workspace = true
wasi.workspace = true
```

**Step 2: Create error.rs**

```rust
// crates/a2a-transport-wasi/src/error.rs
use thiserror::Error;

#[derive(Debug, Error)]
pub enum WasiError {
    #[error("WASI HTTP error: {0}")]
    Http(String),

    #[error("Stream error: {0}")]
    Stream(String),

    #[error("Invalid request: {0}")]
    InvalidRequest(String),
}
```

**Step 3: Create lib.rs with placeholder implementations**

```rust
// crates/a2a-transport-wasi/src/lib.rs
//! WASI HTTP transport implementation.

pub mod error;

pub use error::WasiError;

use a2a_transport::{HttpClient, HttpRequest, HttpResponse};
use bytes::Bytes;
use futures_core::Stream;
use std::future::Future;
use std::pin::Pin;

/// WASI HTTP client using wasi:http.
pub struct WasiHttpClient;

impl WasiHttpClient {
    pub fn new() -> Self {
        Self
    }
}

impl Default for WasiHttpClient {
    fn default() -> Self {
        Self::new()
    }
}

impl HttpClient for WasiHttpClient {
    type Error = WasiError;

    fn request(
        &self,
        _request: HttpRequest,
    ) -> impl Future<Output = Result<HttpResponse, Self::Error>> + Send {
        async move {
            // TODO: Implement using wasi::http::outgoing_handler
            todo!("WASI HTTP client not yet implemented")
        }
    }

    fn request_stream(
        &self,
        _request: HttpRequest,
    ) -> impl Future<
        Output = Result<
            impl Stream<Item = Result<Bytes, Self::Error>> + Send,
            Self::Error,
        >,
    > + Send {
        async move {
            // TODO: Implement streaming using wasi::http
            let stream: Pin<Box<dyn Stream<Item = Result<Bytes, WasiError>> + Send>> =
                Box::pin(futures_core::stream::empty());
            Ok(stream)
        }
    }
}

/// WASI HTTP server using wasi:http/incoming-handler.
pub struct WasiHttpServer;

impl WasiHttpServer {
    pub fn new() -> Self {
        Self
    }
}

impl Default for WasiHttpServer {
    fn default() -> Self {
        Self::new()
    }
}
```

**Step 4: Verify build**

Run: `cargo build -p a2a-transport-wasi`
Expected: Success (with todos)

**Step 5: Commit**

```bash
git add crates/a2a-transport-wasi/
git commit -m "feat(a2a-transport-wasi): add WASI transport scaffold"
```

---

## Task 8: Create a2a-client Crate

**Files:**
- Create: `crates/a2a-client/Cargo.toml`
- Create: `crates/a2a-client/src/lib.rs`
- Create: `crates/a2a-client/src/error.rs`
- Create: `crates/a2a-client/src/jsonrpc.rs`
- Create: `crates/a2a-client/src/sse.rs`

**Step 1: Create Cargo.toml**

```toml
[package]
name = "a2a-client"
version.workspace = true
edition.workspace = true
license.workspace = true

[dependencies]
a2a-types.workspace = true
a2a-transport.workspace = true
serde.workspace = true
serde_json.workspace = true
thiserror.workspace = true
futures-core.workspace = true
bytes.workspace = true
```

**Step 2: Create error.rs**

```rust
// crates/a2a-client/src/error.rs
use thiserror::Error;

#[derive(Debug, Error)]
pub enum Error {
    #[error(transparent)]
    Types(#[from] a2a_types::error::Error),

    #[error("Transport error: {0}")]
    Transport(String),

    #[error("JSON-RPC error {code}: {message}")]
    JsonRpc {
        code: i32,
        message: String,
        data: Option<serde_json::Value>,
    },

    #[error("Agent not found at {0}")]
    AgentNotFound(String),

    #[error("Task not found: {0}")]
    TaskNotFound(String),

    #[error("JSON error: {0}")]
    Json(#[from] serde_json::Error),

    #[error("SSE parse error: {0}")]
    SseParse(String),
}

pub type Result<T> = std::result::Result<T, Error>;
```

**Step 3: Create jsonrpc.rs**

```rust
// crates/a2a-client/src/jsonrpc.rs
use serde::{Deserialize, Serialize};
use serde_json::Value;

#[derive(Debug, Serialize)]
pub struct JsonRpcRequest<T> {
    pub jsonrpc: &'static str,
    pub id: String,
    pub method: String,
    pub params: T,
}

impl<T> JsonRpcRequest<T> {
    pub fn new(id: impl Into<String>, method: impl Into<String>, params: T) -> Self {
        Self {
            jsonrpc: "2.0",
            id: id.into(),
            method: method.into(),
            params,
        }
    }
}

#[derive(Debug, Deserialize)]
pub struct JsonRpcResponse<T> {
    pub jsonrpc: String,
    pub id: String,
    #[serde(flatten)]
    pub result: JsonRpcResult<T>,
}

#[derive(Debug, Deserialize)]
#[serde(untagged)]
pub enum JsonRpcResult<T> {
    Success { result: T },
    Error { error: JsonRpcError },
}

#[derive(Debug, Deserialize)]
pub struct JsonRpcError {
    pub code: i32,
    pub message: String,
    pub data: Option<Value>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_serialize_request() {
        let req = JsonRpcRequest::new("1", "message/send", serde_json::json!({"content": "hello"}));
        let json = serde_json::to_string(&req).unwrap();
        assert!(json.contains("\"jsonrpc\":\"2.0\""));
        assert!(json.contains("\"method\":\"message/send\""));
    }

    #[test]
    fn test_deserialize_success_response() {
        let json = r#"{"jsonrpc":"2.0","id":"1","result":{"status":"ok"}}"#;
        let resp: JsonRpcResponse<Value> = serde_json::from_str(json).unwrap();
        assert!(matches!(resp.result, JsonRpcResult::Success { .. }));
    }

    #[test]
    fn test_deserialize_error_response() {
        let json = r#"{"jsonrpc":"2.0","id":"1","error":{"code":-32001,"message":"Task not found"}}"#;
        let resp: JsonRpcResponse<Value> = serde_json::from_str(json).unwrap();
        assert!(matches!(resp.result, JsonRpcResult::Error { .. }));
    }
}
```

**Step 4: Create sse.rs**

```rust
// crates/a2a-client/src/sse.rs
//! Server-Sent Events (SSE) parser.

use bytes::Bytes;

#[derive(Debug, Clone, PartialEq)]
pub struct SseEvent {
    pub event: Option<String>,
    pub data: String,
    pub id: Option<String>,
}

pub struct SseParser {
    buffer: String,
}

impl SseParser {
    pub fn new() -> Self {
        Self {
            buffer: String::new(),
        }
    }

    /// Feed bytes into the parser and return any complete events.
    pub fn feed(&mut self, chunk: &Bytes) -> Vec<SseEvent> {
        let text = String::from_utf8_lossy(chunk);
        self.buffer.push_str(&text);

        let mut events = Vec::new();

        // Split on double newlines (event boundaries)
        while let Some(pos) = self.buffer.find("\n\n") {
            let event_text = self.buffer[..pos].to_string();
            self.buffer = self.buffer[pos + 2..].to_string();

            if let Some(event) = Self::parse_event(&event_text) {
                events.push(event);
            }
        }

        events
    }

    fn parse_event(text: &str) -> Option<SseEvent> {
        let mut event = None;
        let mut data_lines = Vec::new();
        let mut id = None;

        for line in text.lines() {
            if line.starts_with("event:") {
                event = Some(line[6..].trim().to_string());
            } else if line.starts_with("data:") {
                data_lines.push(line[5..].trim().to_string());
            } else if line.starts_with("id:") {
                id = Some(line[3..].trim().to_string());
            }
        }

        if data_lines.is_empty() {
            return None;
        }

        Some(SseEvent {
            event,
            data: data_lines.join("\n"),
            id,
        })
    }
}

impl Default for SseParser {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_simple_event() {
        let mut parser = SseParser::new();
        let events = parser.feed(&Bytes::from("data: hello world\n\n"));
        assert_eq!(events.len(), 1);
        assert_eq!(events[0].data, "hello world");
        assert!(events[0].event.is_none());
    }

    #[test]
    fn test_parse_event_with_type() {
        let mut parser = SseParser::new();
        let events = parser.feed(&Bytes::from("event: message\ndata: hello\n\n"));
        assert_eq!(events.len(), 1);
        assert_eq!(events[0].event, Some("message".to_string()));
        assert_eq!(events[0].data, "hello");
    }

    #[test]
    fn test_parse_multiline_data() {
        let mut parser = SseParser::new();
        let events = parser.feed(&Bytes::from("data: line1\ndata: line2\n\n"));
        assert_eq!(events.len(), 1);
        assert_eq!(events[0].data, "line1\nline2");
    }

    #[test]
    fn test_parse_multiple_events() {
        let mut parser = SseParser::new();
        let events = parser.feed(&Bytes::from("data: first\n\ndata: second\n\n"));
        assert_eq!(events.len(), 2);
        assert_eq!(events[0].data, "first");
        assert_eq!(events[1].data, "second");
    }

    #[test]
    fn test_parse_chunked() {
        let mut parser = SseParser::new();
        let events1 = parser.feed(&Bytes::from("data: hel"));
        assert_eq!(events1.len(), 0);
        let events2 = parser.feed(&Bytes::from("lo\n\n"));
        assert_eq!(events2.len(), 1);
        assert_eq!(events2[0].data, "hello");
    }
}
```

**Step 5: Create lib.rs**

```rust
// crates/a2a-client/src/lib.rs
//! A2A protocol client.

pub mod error;
pub mod jsonrpc;
pub mod sse;

pub use error::{Error, Result};

use a2a_transport::{HttpClient, HttpRequest};
use jsonrpc::{JsonRpcRequest, JsonRpcResponse, JsonRpcResult};
use std::sync::atomic::{AtomicU64, Ordering};

/// A2A client for communicating with A2A agents.
pub struct Client<T: HttpClient> {
    transport: T,
    base_url: String,
    request_id: AtomicU64,
}

impl<T: HttpClient> Client<T> {
    /// Create a new client with the given transport and base URL.
    pub fn new(transport: T, base_url: impl Into<String>) -> Self {
        Self {
            transport,
            base_url: base_url.into(),
            request_id: AtomicU64::new(1),
        }
    }

    /// Get the next request ID.
    fn next_id(&self) -> String {
        self.request_id.fetch_add(1, Ordering::SeqCst).to_string()
    }

    /// Discover an agent by fetching its agent card.
    pub async fn discover(&self) -> Result<serde_json::Value> {
        let url = format!("{}/.well-known/agent.json", self.base_url.trim_end_matches('/'));
        let request = HttpRequest::get(&url)
            .with_header("Accept", "application/json");

        let response = self.transport.request(request).await
            .map_err(|e| Error::Transport(e.to_string()))?;

        if response.status != 200 {
            return Err(Error::AgentNotFound(url));
        }

        let agent_card: serde_json::Value = serde_json::from_slice(&response.body)?;
        Ok(agent_card)
    }

    /// Send a JSON-RPC request to the agent.
    pub async fn rpc<P, R>(&self, method: &str, params: P) -> Result<R>
    where
        P: serde::Serialize,
        R: serde::de::DeserializeOwned,
    {
        let request = JsonRpcRequest::new(self.next_id(), method, params);
        let body = serde_json::to_vec(&request)?;

        let url = format!("{}/", self.base_url.trim_end_matches('/'));
        let http_request = HttpRequest::post(&url, body)
            .with_header("Content-Type", "application/json")
            .with_header("Accept", "application/json");

        let response = self.transport.request(http_request).await
            .map_err(|e| Error::Transport(e.to_string()))?;

        let rpc_response: JsonRpcResponse<R> = serde_json::from_slice(&response.body)?;

        match rpc_response.result {
            JsonRpcResult::Success { result } => Ok(result),
            JsonRpcResult::Error { error } => Err(Error::JsonRpc {
                code: error.code,
                message: error.message,
                data: error.data,
            }),
        }
    }
}
```

**Step 6: Verify build and run tests**

Run: `cargo build -p a2a-client && cargo test -p a2a-client`
Expected: Success

**Step 7: Commit**

```bash
git add crates/a2a-client/
git commit -m "feat(a2a-client): add client with JSON-RPC and SSE support"
```

---

## Task 9: Create a2a-server Crate

**Files:**
- Create: `crates/a2a-server/Cargo.toml`
- Create: `crates/a2a-server/src/lib.rs`
- Create: `crates/a2a-server/src/error.rs`
- Create: `crates/a2a-server/src/handler.rs`
- Create: `crates/a2a-server/src/store.rs`

**Step 1: Create Cargo.toml**

```toml
[package]
name = "a2a-server"
version.workspace = true
edition.workspace = true
license.workspace = true

[dependencies]
a2a-types.workspace = true
a2a-transport.workspace = true
serde.workspace = true
serde_json.workspace = true
thiserror.workspace = true
futures-core.workspace = true
bytes.workspace = true
```

**Step 2: Create error.rs**

```rust
// crates/a2a-server/src/error.rs
use thiserror::Error;

#[derive(Debug, Error)]
pub enum Error {
    #[error(transparent)]
    Types(#[from] a2a_types::error::Error),

    #[error("Transport error: {0}")]
    Transport(String),

    #[error("Store error: {0}")]
    Store(String),

    #[error("Handler error: {0}")]
    Handler(String),

    #[error("JSON error: {0}")]
    Json(#[from] serde_json::Error),

    #[error("Method not found: {0}")]
    MethodNotFound(String),

    #[error("Invalid params: {0}")]
    InvalidParams(String),
}

pub type Result<T> = std::result::Result<T, Error>;
```

**Step 3: Create handler.rs with AgentHandler trait**

```rust
// crates/a2a-server/src/handler.rs
use futures_core::Stream;
use std::future::Future;

/// Context for a request.
#[derive(Debug, Clone, Default)]
pub struct RequestContext {
    pub task_id: Option<String>,
    pub context_id: Option<String>,
}

/// User-implemented handler for agent logic.
pub trait AgentHandler: Send + Sync {
    /// Error type for this handler.
    type Error: std::error::Error + Send + Sync + 'static;

    /// Stream type for streaming responses.
    type EventStream: Stream<Item = serde_json::Value> + Send + Unpin;

    /// Handle a non-streaming message.
    fn handle_message(
        &self,
        message: serde_json::Value,
        context: RequestContext,
    ) -> impl Future<Output = Result<serde_json::Value, Self::Error>> + Send;

    /// Handle a streaming message.
    fn handle_message_stream(
        &self,
        message: serde_json::Value,
        context: RequestContext,
    ) -> impl Future<Output = Result<Self::EventStream, Self::Error>> + Send;

    /// Handle task cancellation.
    fn handle_cancel(
        &self,
        task_id: &str,
    ) -> impl Future<Output = Result<serde_json::Value, Self::Error>> + Send;
}
```

**Step 4: Create store.rs with TaskStore trait**

```rust
// crates/a2a-server/src/store.rs
use std::collections::HashMap;
use std::future::Future;
use std::sync::RwLock;

/// Filter for listing tasks.
#[derive(Debug, Clone, Default)]
pub struct TaskFilter {
    pub context_id: Option<String>,
    pub status: Option<String>,
}

/// Task storage trait.
pub trait TaskStore: Send + Sync {
    /// Error type for this store.
    type Error: std::error::Error + Send + Sync + 'static;

    /// Get a task by ID.
    fn get(
        &self,
        task_id: &str,
    ) -> impl Future<Output = Result<Option<serde_json::Value>, Self::Error>> + Send;

    /// Save a task.
    fn save(
        &self,
        task: &serde_json::Value,
    ) -> impl Future<Output = Result<(), Self::Error>> + Send;

    /// List tasks matching the filter.
    fn list(
        &self,
        filter: TaskFilter,
    ) -> impl Future<Output = Result<Vec<serde_json::Value>, Self::Error>> + Send;

    /// Delete a task.
    fn delete(
        &self,
        task_id: &str,
    ) -> impl Future<Output = Result<(), Self::Error>> + Send;
}

/// In-memory task store.
#[derive(Debug, Default)]
pub struct InMemoryTaskStore {
    tasks: RwLock<HashMap<String, serde_json::Value>>,
}

impl InMemoryTaskStore {
    pub fn new() -> Self {
        Self::default()
    }
}

impl TaskStore for InMemoryTaskStore {
    type Error = std::convert::Infallible;

    async fn get(&self, task_id: &str) -> Result<Option<serde_json::Value>, Self::Error> {
        let tasks = self.tasks.read().unwrap();
        Ok(tasks.get(task_id).cloned())
    }

    async fn save(&self, task: &serde_json::Value) -> Result<(), Self::Error> {
        if let Some(id) = task.get("id").and_then(|v| v.as_str()) {
            let mut tasks = self.tasks.write().unwrap();
            tasks.insert(id.to_string(), task.clone());
        }
        Ok(())
    }

    async fn list(&self, filter: TaskFilter) -> Result<Vec<serde_json::Value>, Self::Error> {
        let tasks = self.tasks.read().unwrap();
        let result: Vec<_> = tasks
            .values()
            .filter(|task| {
                if let Some(ref ctx) = filter.context_id {
                    if task.get("context_id").and_then(|v| v.as_str()) != Some(ctx) {
                        return false;
                    }
                }
                if let Some(ref status) = filter.status {
                    if task.get("status").and_then(|v| v.get("state")).and_then(|v| v.as_str()) != Some(status) {
                        return false;
                    }
                }
                true
            })
            .cloned()
            .collect();
        Ok(result)
    }

    async fn delete(&self, task_id: &str) -> Result<(), Self::Error> {
        let mut tasks = self.tasks.write().unwrap();
        tasks.remove(task_id);
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[tokio::test]
    async fn test_in_memory_store() {
        let store = InMemoryTaskStore::new();

        let task = json!({
            "id": "task-1",
            "context_id": "ctx-1",
            "status": { "state": "submitted" }
        });

        // Save
        store.save(&task).await.unwrap();

        // Get
        let retrieved = store.get("task-1").await.unwrap();
        assert!(retrieved.is_some());
        assert_eq!(retrieved.unwrap()["id"], "task-1");

        // List
        let all = store.list(TaskFilter::default()).await.unwrap();
        assert_eq!(all.len(), 1);

        // Delete
        store.delete("task-1").await.unwrap();
        let deleted = store.get("task-1").await.unwrap();
        assert!(deleted.is_none());
    }
}
```

**Step 5: Create lib.rs**

```rust
// crates/a2a-server/src/lib.rs
//! A2A protocol server.

pub mod error;
pub mod handler;
pub mod store;

pub use error::{Error, Result};
pub use handler::{AgentHandler, RequestContext};
pub use store::{InMemoryTaskStore, TaskFilter, TaskStore};
```

**Step 6: Update Cargo.toml for dev-dependencies**

```toml
# Add to crates/a2a-server/Cargo.toml
[dev-dependencies]
tokio = { version = "1.48.0", features = ["rt", "macros"] }
```

**Step 7: Verify build and run tests**

Run: `cargo build -p a2a-server && cargo test -p a2a-server`
Expected: Success

**Step 8: Commit**

```bash
git add crates/a2a-server/
git commit -m "feat(a2a-server): add server with AgentHandler and TaskStore traits"
```

---

## Task 10: Create a2a-wasm-component Crate Scaffold

**Files:**
- Create: `crates/a2a-wasm-component/Cargo.toml`
- Create: `crates/a2a-wasm-component/src/lib.rs`
- Create: `crates/a2a-wasm-component/wit/a2a.wit`

**Step 1: Create Cargo.toml**

```toml
[package]
name = "a2a-wasm-component"
version.workspace = true
edition.workspace = true
license.workspace = true

[lib]
crate-type = ["cdylib"]

[dependencies]
a2a-types.workspace = true
a2a-client.workspace = true
a2a-server.workspace = true
a2a-transport-wasi.workspace = true
wit-bindgen.workspace = true
serde.workspace = true
serde_json.workspace = true
```

**Step 2: Create wit/a2a.wit**

```wit
// crates/a2a-wasm-component/wit/a2a.wit
package agent-compose:a2a@0.1.0;

interface types {
    enum role {
        user,
        agent,
    }

    record message {
        role: role,
        content: string,
        context-id: option<string>,
    }

    enum task-status {
        submitted,
        working,
        completed,
        failed,
        cancelled,
    }

    record task {
        id: string,
        status: task-status,
        context-id: option<string>,
        messages: list<message>,
        artifacts: list<string>,
    }

    variant send-response {
        message(message),
        task(task),
    }

    record pending-item {
        id: string,
        from: string,
        content: string,
        context-id: option<string>,
        task-id: option<string>,
    }
}

interface client {
    use types.{message, task, task-status, send-response};

    send-message: func(to: string, content: string, context-id: option<string>) -> send-response;
    get-task: func(task-id: string) -> option<task>;
    list-tasks: func(context-id: option<string>, status: option<task-status>) -> list<task>;
    cancel-task: func(task-id: string) -> option<task>;
}

interface server {
    use types.{pending-item};

    get-inbox: func(agent-name: string) -> list<pending-item>;
    acknowledge: func(agent-name: string, item-id: string) -> bool;
}

world a2a-component {
    export client;
    export server;
}
```

**Step 3: Create lib.rs with placeholder**

```rust
// crates/a2a-wasm-component/src/lib.rs
//! A2A WASM component with agent-compose:a2a interface.

// WIT bindings will be generated here
// wit_bindgen::generate!({
//     world: "a2a-component",
//     path: "wit",
// });

// Placeholder - actual implementation will use wit-bindgen
pub fn placeholder() {
    // TODO: Implement WIT exports
}
```

**Step 4: Verify build (will have warnings about unused)**

Run: `cargo build -p a2a-wasm-component`
Expected: Success with warnings

**Step 5: Commit**

```bash
git add crates/a2a-wasm-component/
git commit -m "feat(a2a-wasm-component): add WASM component scaffold with WIT interface"
```

---

## Task 11: Integration Test Setup

**Files:**
- Create: `tests/README.md`
- Create: `scripts/test-cross-impl.sh`

**Step 1: Create tests README**

```markdown
# A2A Rust Integration Tests

## Cross-Implementation Testing

Tests are run against other A2A implementations (JS, Python) rather than mocks.

### Prerequisites

1. Clone JS SDK: `git clone https://github.com/a2aproject/a2a-js ../a2a-js`
2. Clone Python SDK: `git clone https://github.com/a2aproject/a2a-python ../a2a-python`

### Running Tests

#### Test Rust Client against JS SUT Agent

```bash
cd ../a2a-js
npm install
npm run tck:sut-agent &  # Starts on port 41241

cd ../a2a-rust
cargo test --test client_integration
```

#### Test Rust Server with Python Client

```bash
cargo run --example echo-agent &  # Start Rust server

cd ../a2a-python
pytest tests/integration/test_client_server_integration.py
```
```

**Step 2: Create test script**

```bash
#!/bin/bash
# scripts/test-cross-impl.sh

set -e

echo "=== A2A Cross-Implementation Tests ==="

# Check for JS SDK
if [ ! -d "../a2a-js" ]; then
    echo "JS SDK not found. Clone it first:"
    echo "  git clone https://github.com/a2aproject/a2a-js ../a2a-js"
    exit 1
fi

# Start JS SUT Agent
echo "Starting JS SUT Agent..."
cd ../a2a-js
npm run tck:sut-agent &
SUT_PID=$!
sleep 3

# Run Rust client tests
echo "Running Rust client integration tests..."
cd ../a2a-rust
cargo test --test client_integration || true

# Cleanup
kill $SUT_PID 2>/dev/null || true

echo "=== Tests Complete ==="
```

**Step 3: Make script executable**

Run: `chmod +x scripts/test-cross-impl.sh`

**Step 4: Commit**

```bash
git add tests/ scripts/
git commit -m "docs: add cross-implementation test setup"
```

---

## Summary

This plan covers the initial implementation of all 6 core crates:

1. **a2a-types** - Generated types from JSON Schema
2. **a2a-transport** - HTTP transport traits
3. **a2a-transport-wasi** - WASI implementation scaffold
4. **a2a-client** - Client with JSON-RPC and SSE
5. **a2a-server** - Server with AgentHandler and TaskStore
6. **a2a-wasm-component** - WIT interface scaffold

**Next steps after this plan:**
- Implement full WASI HTTP client/server
- Add generated types from actual A2A schema
- Implement streaming in client
- Add routing logic in server
- Complete WASM component exports
- Run cross-implementation tests
